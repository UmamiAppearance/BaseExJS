class t{constructor(t){this.root=t,"charsets"in t&&this.charsetUserToolsConstructor(),this.smartInput=new e,this.smartOutput=new r}charsetUserToolsConstructor(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const r=this.root.converter.radix;let n=r;if("string"==typeof e||Array.isArray(e))n=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==r)throw n===r?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The the length of the charset must be ${r}.`);e=[...e].join(""),this.root.charsets[t]=e,console.log(`New charset added with the name '${t}' added and ready to use`)},this.root.setDefaultVersion=t=>[this.root.version]=this.validateArgs([t])}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}normalizeOutput(t){let e=2**Math.ceil(Math.log(t.byteLength)/Math.log(2));e=Math.max(e,2);const r=e-t.byteLength;if(r){const n=new Uint8Array(e);n.set(t,r),t=n}return t}negate(t){t.forEach(((e,r)=>t[r]=255^e));const e=t.byteLength-1;t[e]+=1}toSignedArray(t,e){return t=this.normalizeOutput(t),e&&this.negate(t),t}invalidArgument(t,e,r){const n=this.root.isMutable.signed?"\n * 'signed' to disable, 'unsigned', to enable the use of the twos's complement for negative integers":"",i=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",s=this.root.isMutable.padding?"\n * 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",o=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",a=`\n * valid args for the output type are ${this.makeArgList(r)}`,h=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nValid parameters are:${n}${i}${s}${o}${a}${h}\n\nTraceback:`)}validateArgs(t,e=!1){const r={version:this.root.version,signed:this.root.signed,littleEndian:this.root.littleEndian,padding:this.root.padding,outputType:"buffer"};if(!t.length)return r;const n=Object.keys(this.root.charsets),i=this.smartOutput.typeList,s={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(t.forEach((t=>{if(t=String(t).toLowerCase(),n.includes(t))r.version=t;else if(i.includes(t))r.outputType=t;else{let e=!0;for(const n in s)if(s[n].includes(t)){if(e=!1,!this.root.isMutable[n])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);r[n]=Boolean(s[n].indexOf(t))}e&&this.invalidArgument(t,n,i)}})),r.padding&&r.signed&&(r.padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),e)for(const t in r)this.root[t]=r[t];return r}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(t){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(t):console.log(`___\n${t}\n`)}}class e{makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}floatingPoints(t,e=!1){let r;if(t>12e-39&&t<34e37)r=this.makeDataView(4),r.setFloat32(0,t,e);else{if(!(t>23e-309&&t<17e307))throw new RangeError("Float is too complex to handle. Convert it to bytes manually before encoding.");r=this.makeDataView(8),r.setFloat64(0,t,e)}return r}numbers(t,e=!1){let r;if(Number.isInteger(t)){if(!Number.isSafeInteger(t)){let e,r,n;throw t<0?(e=Number.MIN_SAFE_INTEGER,r="smaller",n="MIN"):(e=Number.MAX_SAFE_INTEGER,r="bigger",n="MAX"),new RangeError(`The provided integer is ${r} than ${n}_SAFE_INTEGER: '${e}'\nData integrity is not possible. Use a BigInt to avoid this issue.`)}t<0?t<-2147483648?(r=this.makeDataView(8),r.setBigInt64(0,BigInt(t),e)):t<-32768?(r=this.makeDataView(4),r.setInt32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):t>0?t>4294967295?(r=this.makeDataView(8),r.setBigUint64(0,BigInt(t),e)):t>65535?(r=this.makeDataView(4),r.setUint32(0,t,e)):(r=this.makeDataView(2),r.setInt16(0,t,e)):r=new Uint16Array([0])}else r=this.floatingPoints(t,e);return new Uint8Array(r.buffer)}bigInts(t,e=!1){const r=new Array,n=e?"push":"unshift";if(t>0){const e=18446744073709551616n;for(;t>=e;)r[n](t%e),t>>=64n}else if(t<0){const e=-9223372036854775808n;for(;t<=e;)r[n](t%e),t>>=64n}r[n](t);const i=8*r.length,s=new ArrayBuffer(i),o=new DataView(s);return r.forEach(((t,r)=>{const n=8*r;o.setBigUint64(n,t,e)})),new Uint8Array(o.buffer)}toBytes(t,e=!1,r=!1){let n,i=!1,s=!1;if(t instanceof ArrayBuffer)n=new Uint8Array(t),s=!0;else if(ArrayBuffer.isView(t))n=new Uint8Array(t.buffer),s=!0;else if("string"==typeof t||t instanceof String)n=(new TextEncoder).encode(t);else if("number"!=typeof t||isNaN(t)||t===1/0)if("bigint"==typeof t)e&&t<0&&(i=!0,t*=-1n),n=this.bigInts(t,r);else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const e=new Array;for(const r of t)e.push(...this.toBytes(r));n=Uint8Array.from(e)}}else e&&t<0&&(i=!0,t*=-1),n=this.numbers(t,r);return[n,i,s]}}class r{constructor(){this.typeList=this.constructor.validTypes()}getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}makeTypedArrayBuffer(t,e,r){const n=t.byteLength,i=(e-t.byteLength%e)%e;let s=t;if(i){s=new Uint8Array(n+i);const e=r?i:0;s.set(t,e)}return s.buffer}makeTypedArray(t,e,r){let n;if("int16"===e||"uint16"===e){const i=this.makeTypedArrayBuffer(t,2,r);n="int16"===e?new Int16Array(i):new Uint16Array(i)}else if("int32"===e||"uint32"===e){const i=this.makeTypedArrayBuffer(t,4,r);n="int32"===e?new Int32Array(i):new Uint32Array(i)}else if("bigint64"===e||"biguint64"===e){const i=this.makeTypedArrayBuffer(t,8,r);n="bigint64"===e?new BigInt64Array(i):new BigUint64Array(i)}return n}compile(t,e,r=!1,n=!1){let i;if("buffer"===(e=this.getType(e)))i=t.buffer;else if("bytes"===e||"Uint8"===e)i=t;else if("int8"===e)i=new Int8Array(t.buffer);else if("view"===e)i=new DataView(t.buffer);else if("str"===e)i=(new TextDecoder).decode(t);else if("number"===e){i=t,r&&i.reverse();let e=0n;i.forEach((t=>e=(e<<8n)+BigInt(t))),i=e<Number.MAX_SAFE_INTEGER?Number(e):e,n&&(i=-i)}else i=this.makeTypedArray(t,e,r);return i}static validTypes(){return["bigint64","biguint64","buffer","bytes","int8","int16","int32","number","str","uint8","uint16","uint32","view"]}}class n{constructor(...e){this.byteOrder="BE",this.charsets={default:'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'},this.littleEndian=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,this.utils=new t(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1},this.utils.validateArgs(e,!0)}encode(t,...e){const r=this.utils.validateArgs(e),n=this.utils.smartInput.toBytes(t,r.signed,r.littleEndian)[0];let i=0,s=0,o="";const a=this.charsets[r.version];if(n.forEach((t=>{if(s+=t<<i,i+=8,i>13){let t,e,r=13,n=s%8192;n<89&&(r=14,n=s%16384),s>>=r,i-=r,[t,e]=this.divmod(n,91),o=`${o}${a[e]}${a[t]}`}})),i){let t,e;[t,e]=this.divmod(s,91),o=o.concat(a[e]),(i>7||s>90)&&(o=o.concat(a[t]))}return o}decode(t,...e){const r=this.utils.validateArgs(e);let n=(t=String(t)).length,i=!1;n%2&&(i=!0,n--);let s=0,o=0;const a=this.charsets[r.version],h=new Array;for(let e=0;e<n;e+=2){const r=a.indexOf(t[e])+91*a.indexOf(t[e+1]);s=(r<<o)+s,o+=r%8192>88?13:14;do{h.push(s%256),s>>=8,o-=8}while(o>7)}if(i){const e=t.charAt(n),r=a.indexOf(e);h.push(((r<<o)+s)%256)}const u=Uint8Array.from(h);return this.utils.smartOutput.compile(u,r.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}export{n as Base91};
