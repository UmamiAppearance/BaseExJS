class t{toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{constructor(){this.typeList=this.constructor.validTypes()}getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}compile(t,e){let n;return n="buffer"===(e=this.getType(e))?t.buffer:"view"===e?new DataView(t.buffer):t,n}static validTypes(){return["buffer","bytes","uint8","view"]}}let n=class{makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}floatingPoints(t,e=!1){const n=this.makeDataView(8);return n.setFloat64(0,t,e),n}numbers(t,e=!1){let n,r;if(Number.isInteger(t)){if(r="int",!Number.isSafeInteger(t)){let e,n,r;throw t<0?(e=Number.MIN_SAFE_INTEGER,n="smaller",r="MIN"):(e=Number.MAX_SAFE_INTEGER,n="bigger",r="MAX"),new RangeError(`The provided integer is ${n} than ${r}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(n=this.makeDataView(8),n.setBigInt64(0,BigInt(t),e)):t<-32768?(n=this.makeDataView(4),n.setInt32(0,t,e)):(n=this.makeDataView(2),n.setInt16(0,t,e)):t>0?t>4294967295?(n=this.makeDataView(8),n.setBigUint64(0,BigInt(t),e)):t>65535?(n=this.makeDataView(4),n.setUint32(0,t,e)):(n=this.makeDataView(2),n.setInt16(0,t,e)):n=new Uint16Array([0])}else r="float",n=this.floatingPoints(t,e);return[new Uint8Array(n.buffer),r]}bigInts(t,e=!1){const n=new Array,r=e?"push":"unshift",i=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)n[r](t%i),t>>=64n;else for(;t>=i;)n[r](t%i),t>>=64n;n[r](t);const s=8*n.length,o=this.makeDataView(s);return n.forEach(((t,n)=>{const r=8*n;o.setBigUint64(r,t,e)})),new Uint8Array(o.buffer)}toBytes(t,e){let n,r=!1,i="bytes";if(t instanceof ArrayBuffer)n=new Uint8Array(t);else if(ArrayBuffer.isView(t))n=new Uint8Array(t.buffer);else if("string"==typeof t||t instanceof String)n=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(r=!0,t=-t),e.numberMode){const r=this.floatingPoints(t,e.littleEndian);n=new Uint8Array(r.buffer),i="float"}else[n,i]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(r=!0,t*=-1n),n=this.bigInts(t,e.littleEndian),i="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const e=new Array;for(const n of t)e.push(...this.toBytes(n));n=Uint8Array.from(e)}}return[n,r,i]}},r=class{constructor(){this.typeList=this.constructor.validTypes()}getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}makeTypedArrayBuffer(t,e,n){const r=t.byteLength,i=(e-t.byteLength%e)%e;let s=t;if(i){s=new Uint8Array(r+i);const e=n?i:0;s.set(t,e)}return s.buffer}makeTypedArray(t,e,n){let r;if("int16"===e||"uint16"===e){const i=this.makeTypedArrayBuffer(t,2,n);r="int16"===e?new Int16Array(i):new Uint16Array(i)}else if("int32"===e||"uint32"===e||"float32"===e){const i=this.makeTypedArrayBuffer(t,4,n);r="int32"===e?new Int32Array(i):"uint32"===e?new Uint32Array(i):new Float32Array(i)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const i=this.makeTypedArrayBuffer(t,8,n);r="bigint64"===e?new BigInt64Array(i):"biguint64"===e?new BigUint64Array(i):new Float64Array(i)}return r}compile(t,e,n=!1,r=!1){let i;if("buffer"===(e=this.getType(e)))i=t.buffer;else if("bytes"===e||"uint8"===e)i=t;else if("int8"===e)i=new Int8Array(t.buffer);else if("view"===e)i=new DataView(t.buffer);else if("str"===e)i=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){n&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"int_n"===e&&(s=BigInt.asIntN(8*t.length,s)),i="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s,r&&(i=-i)}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1);i=new DataView(e.buffer).getFloat32(0,n)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1);i=new DataView(e.buffer).getFloat64(0,n)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);i=Number(e)}else i=this.makeTypedArray(t,e,n);return i}static validTypes(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}};class i{constructor(t){this.root=t,"charsets"in t&&this.charsetUserToolsConstructor()}setIOHandlers(t=n,e=r){this.inputHandler=new t,this.outputHandler=new e}charsetUserToolsConstructor(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const n=this.root.converter.radix;let r=n;if("string"==typeof e||Array.isArray(e))r=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==n)throw r===n?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The the length of the charset must be ${n}.`);e=[...e].join(""),this.root.charsets[t]=e,console.log(`New charset added with the name '${t}' added and ready to use`)},this.root.setDefaultVersion=t=>[this.root.version]=this.validateArgs([t])}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,n,r){const i=r?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",s=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned', to enable the use of the twos's complement for negative integers":"",o=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",a=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",l=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",h=`\n * valid args for the output type are ${this.makeArgList(n)}`,u=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${i}${s}${o}${a}${l}${h}${u}\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)\n\nTraceback:`)}validateArgs(i,s=!1){const o={littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};if(!i.length)return s&&this.setIOHandlers(),o;const a=t=>!!i.includes(t)&&(i.splice(i.indexOf(t),1),!0),l=Object.keys(this.root.charsets),h={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(s)if(a("bytes_only"))this.setIOHandlers(t,e);else{const i=a("bytes_in")?t:n,s=a("bytes_out")?e:r;this.setIOHandlers(i,s)}const u=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),i.forEach((t=>{if(t=String(t).toLowerCase(),l.includes(t))o.version=t;else if(u.includes(t))o.outputType=t;else{let e=!0;for(const n in h)if(h[n].includes(t)){if(e=!1,!this.root.isMutable[n])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[n]=Boolean(h[n].indexOf(t))}e&&this.invalidArgument(t,l,u,s)}})),o.padding&&o.signed&&(o.padding=!1,this.constructor.warning("Padding was set to false due to the signed conversion.")),s)for(const t in o)this.root[t]=o[t];return o}signError(){throw new TypeError("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter.")}static warning(t){Object.prototype.hasOwnProperty.call(console,"warn")?console.warn(t):console.log(`___\n${t}\n`)}}class s{constructor(t,e=null,n=null,r=0){this.radix=t,null!==e&&null!==n?(this.bsEnc=e,this.bsDec=n):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=r}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let n=0;for(;8*n*Math.log(2)/Math.log(t)<e;)n++;return[n,Math.ceil(8*n*Math.log(2)/Math.log(t))]}encode(t,e,n=!1,r=null){let i=this.bsEnc;0===i&&(i=t.byteLength);let s="";const o=i?(i-t.length%i)%i:0,a=new Array(o).fill(0);let l;n?(t.reverse(),l=[...a,...t]):l=[...t,...a];for(let t=0,n=l.length;t<n;t+=i){let n=0n;for(let e=t;e<t+i;e++)n=(n<<8n)+BigInt(l[e]);const a=new Array;let h,u=n;for(;u>=this.radix;)[u,h]=this.divmod(u,this.radix),a.unshift(parseInt(h,10));for(a.unshift(parseInt(u,10));a.length<this.bsDec;)a.unshift(0);let d="";a.forEach((t=>d=d.concat(e[t]))),r&&(d=r(d,o)),s=s.concat(d)}return[s,o]}decode(t,e,n=!1){if(!t)return new Uint8Array(0);let r=this.bsDec;const i=new Array;let s;if(t.split("").forEach((t=>{const n=e.indexOf(t);n>-1&&i.push(n)})),0===r)r=i.length;else{s=(r-i.length%r)%r;const t=new Array(s).fill(this.decPadVal);n?i.unshift(...t):i.push(...t)}let o=new Array;for(let t=0,e=i.length;t<e;t+=r){let e=0n;for(let n=0;n<r;n++)e+=BigInt(i[t+n])*this.pow(r-1-n);const n=new Array;let s,a=e;for(;a>=256;)[a,s]=this.divmod(a,256),n.unshift(parseInt(s,10));for(n.unshift(parseInt(a,10));n.length<this.bsEnc;)n.unshift(0);o=o.concat(n)}if(n){for(;!o[0];)o.shift();o.length||o.push(0),o.reverse()}else if(this.bsDec){const t=this.padChars(s);o.splice(o.length-t)}return Uint8Array.from(o)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class o extends class{constructor(){this.charsets={},this.hasSignedMode=!1,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,this.utils=new i(this),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,n,...r){const i=this.utils.validateArgs(r);let s,o,a;[s,o,a]=this.utils.inputHandler.toBytes(t,i);let l,h,u=null;return e&&(u=e(i)),[l,h]=this.converter.encode(s,this.charsets[i.version],i.littleEndian,u),i.signed&&(l=this.utils.toSignedStr(l,o)),i.upper&&(l=l.toUpperCase()),n&&(l=n({inputBytes:s,output:l,settings:i,zeroPadding:h,type:a})),l}decode(t,e,n,...r){const i=this.utils.validateArgs(r);let s=String(t),o=!1;this.hasSignedMode&&([s,o]=this.utils.extractSign(s),o&&!i.signed&&this.utils.signError()),this.isMutable.upper&&(s=s.toLowerCase()),e&&(s=e({input:s,settings:i}));let a=this.converter.decode(s,this.charsets[i.version],i.littleEndian);return n&&(a=n({input:s,output:a,settings:i})),this.utils.outputHandler.compile(a,i.outputType,i.littleEndian,o)}}{constructor(t,...e){if(super(),!t||!Number.isInteger(t)||t<2||t>36)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 36.");this.charsets.selection="0123456789abcdefghijklmnopqrstuvwxyz".substring(0,t),this.converter=new s(t,0,0),this.hasSignedMode=!0,this.littleEndian=!(2===t||16===t),this.signed=!0,this.version="selection",this.isMutable.littleEndian=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;if(2===this.converter.radix){const t=(8-e.length%8)%8;e=`${"0".repeat(t)}${e}`}else if(16===this.converter.radix){const t=e.length%2;e=`${"0".repeat(t)}${e}`}return e}),null,...e)}}export{o as SimpleBase};
