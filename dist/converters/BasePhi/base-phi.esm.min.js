class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,i){let r;return r="buffer"===(i=e.getType(i))?t.buffer:"view"===i?new DataView(t.buffer):t,r}}class i{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const i=this.makeDataView(8);return i.setFloat64(0,t,e),i}static numbers(t,e=!1){let i,r;if(Number.isInteger(t)){if(r="int",!Number.isSafeInteger(t)){let e,i,r;throw t<0?(e=Number.MIN_SAFE_INTEGER,i="smaller",r="MIN"):(e=Number.MAX_SAFE_INTEGER,i="bigger",r="MAX"),new RangeError(`The provided integer is ${i} than ${r}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(i=this.makeDataView(8),i.setBigInt64(0,BigInt(t),e)):t<-32768?(i=this.makeDataView(4),i.setInt32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):t>0?t>4294967295?(i=this.makeDataView(8),i.setBigUint64(0,BigInt(t),e)):t>65535?(i=this.makeDataView(4),i.setUint32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):i=new Uint16Array([0])}else r="float",i=this.floatingPoints(t,e);return[new Uint8Array(i.buffer),r]}static bigInts(t,e=!1){const i=new Array,r=e?"push":"unshift",n=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)i[r](t%n),t>>=64n;else for(;t>=n;)i[r](t%n),t>>=64n;i[r](t);const s=8*i.length,o=this.makeDataView(s);return i.forEach(((t,i)=>{const r=8*i;o.setBigUint64(r,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let i,r=!1,n="bytes";if(t instanceof ArrayBuffer)i=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))i=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)i=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(r=!0,t=-t),e.numberMode){const r=this.floatingPoints(t,e.littleEndian);i=new Uint8Array(r.buffer),n="float"}else[i,n]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(r=!0,t*=-1n),i=this.bigInts(t,e.littleEndian),n="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const r=new Array;for(const i of t)r.push(...this.toBytes(i,e)[0]);i=Uint8Array.from(r)}}return[i,r,n]}}const r=i,n=class{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,i,r){const n=t.byteLength,s=(e-t.byteLength%e)%e,o=r&&n>1?255:0;let a=t;if(s){a=new Uint8Array(n+s),a.fill(o);const e=i?0:s;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,i,r){let n;if("int16"===e||"uint16"===e){const s=this.makeTypedArrayBuffer(t,2,i,r);n="int16"===e?new Int16Array(s):new Uint16Array(s)}else if("int32"===e||"uint32"===e||"float32"===e){const s=this.makeTypedArrayBuffer(t,4,i,r);n="int32"===e?new Int32Array(s):"uint32"===e?new Uint32Array(s):new Float32Array(s)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const s=this.makeTypedArrayBuffer(t,8,i,r);n="bigint64"===e?new BigInt64Array(s):"biguint64"===e?new BigUint64Array(s):new Float64Array(s)}return n}static compile(t,e,r=!1,n=!1){let s;if(e=this.getType(e),n){let n;if(n=e.match(/^float/)?-this.compile(t,"float_n",r):-this.compile(t,"uint_n",r),"float_n"===e)return n;t=i.toBytes(n,{littleEndian:r,numberMode:!1,signed:!1})[0]}if("buffer"===e)s=t.buffer;else if("bytes"===e||"uint8"===e)s=t;else if("int8"===e)s=new Int8Array(t.buffer);else if("view"===e)s=new DataView(t.buffer);else if("str"===e)s=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,r,n);t=new Uint8Array(e)}r&&t.reverse();let i=0n;t.forEach((t=>i=(i<<8n)+BigInt(t))),"uint_n"!==e&&(i=BigInt.asIntN(8*t.length,i)),s="bigint_n"!==e&&i>=Number.MIN_SAFE_INTEGER&&i<=Number.MAX_SAFE_INTEGER?Number(i):i}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,n);s=new DataView(e.buffer).getFloat32(0,r)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,n);s=new DataView(e.buffer).getFloat64(0,r)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);s=Number(e)}else s=this.makeTypedArray(t,e,r,n);return s}};class s extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class o extends TypeError{constructor(t,e=null){null===e&&(e=`Character '${t}' is not part of the charset.`),super(e),this.name="DecodingError"}}class a{constructor(t){this.root=t,this.converterArgs={},this.#t()}setIOHandlers(t=r,e=n){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,i=[],r=!0)=>{const n=(t,i,r)=>{if(0===r&&i.length)return console.warn(`This converter has no ${t}. The following argument was ignored:\n'${i}'`),[];let n=r;if("string"==typeof i&&(i=[...i]),Array.isArray(i))n=i.length,i=new Set(i);else if(!(i instanceof Set))throw new TypeError(`The ${t} must be one of the types:\n'str', 'set', 'array'."`);if(i.size===r)return[...i];if(n!==r)throw new Error(`Your ${t} has a length of ${n}. The converter requires a length of ${r}.`);{const i={};(e=[...e]).forEach((t=>{t in i?i[t]++:i[t]=1}));let n="";r<100&&(n=`${e.join("")}\n`,e.forEach((t=>{i[t]>1?n+="^":n+=" "})));const s=Object.keys(i).filter((t=>i[t]>1));throw new Error(`You have repetitive char(s) [ ${s.join(" | ")} ] in your ${t}. Make sure each character is unique.\n${n}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof t)throw new TypeError("The charset name must be a string.");r&&t in this.root.charsets&&console.warn(`An existing charset with name ${t} will get replaced.`);const s=n("charset",e,this.root.converter.radix),o=n("padding set",i,this.root.padCharAmount);this.root.charsets[t]=s,o.length&&(this.root.padChars[t]=o),r&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{if(!(t in this.root.charsets)){const e=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${t} was not found. Available charsets are:\n   * ${e}`)}this.root.version=t}}#e(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}#i(t,e,i,r){throw new TypeError([`'${t}'\n\nParameters:`,r?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",`\n * valid args for the output type are ${this.#e(i)}`,e?`\n * the option(s) for version/charset are: ${this.#e(e)}`:"","\n * valid args for integrity check are: 'integrity' and 'nointegrity'",this.root.hasDecimalMode?"\n * 'decimal' for decimal-mode (directly converts Numbers including decimal values, without byte-conversion)":"","\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)",Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"","\n\nTraceback:"].join(""))}validateArgs(i,s=!1){const o={decimalMode:this.root.decimalMode,integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)o[t]=this.root[t];if(!i.length)return s&&this.setIOHandlers(),o;const a=t=>!!i.includes(t)&&(i.splice(i.indexOf(t),1),!0),l=Object.keys(this.root.charsets),h={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(s)if(a("bytes_only"))this.setIOHandlers(t,e);else{const i=a("bytes_in")?t:r,s=a("bytes_out")?e:n;this.setIOHandlers(i,s)}const u=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),a("decimal")){if(!this.root.hasDecimalMode)throw TypeError("Argument 'decimal' is only allowed for converters with a non-integer base.");o.decimalMode=!0,o.outputType="decimal",o.numberMode&&(o.numberMode=!1,console.warn("-> number-mode was disabled due to the decimal-mode"))}if(i.forEach((t=>{if("object"!=typeof t)if(t=String(t).toLowerCase(),l.includes(t))o.version=t;else if(u.includes(t))o.outputType=t;else{let e=!0;for(const i in h)if(h[i].includes(t)){if(e=!1,!this.root.isMutable[i])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[i]=Boolean(h[i].indexOf(t))}e&&this.#i(t,l,u,s)}else o.options={...o.options,...t}})),o.padding&&o.signed&&(o.padding=!1,console.warn("-> padding was set to false due to the signed conversion")),s)for(const t in o)this.root[t]=o[t];return o}signError(){throw new s}wrapOutput(t,e=0){if(!e)return t;const i=new RegExp(`.{1,${e}}`,"gu");return t.match(i).join("\n")}normalizeInput(t,e=!1){return e?String(t):String(t).replace(/\s/g,"")}}class l{constructor(t,e=null,i=null,r=0){this.radix=t,null!==e&&null!==i?(this.bsEnc=e,this.bsDec=i):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=r,this.powers={}}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let i=0;for(;8*i*Math.log(2)/Math.log(t)<e;)i++;return[i,Math.ceil(8*i*Math.log(2)/Math.log(t))]}encode(t,e,i=!1,r=null){let n=this.bsEnc;0===n&&(n=t.byteLength);let s="";const o=n?(n-t.length%n)%n:0,a=new Array(o).fill(0);let l;if(i?(t.reverse(),l=[...a,...t]):l=[...t,...a],10===this.radix){let t=0n;for(let e=0;e<n;e++)t=(t<<8n)+BigInt(l[e]);return[t.toString(),0]}for(let t=0,i=l.length;t<i;t+=n){let i=0n;for(let e=t;e<t+n;e++)i=(i<<8n)+BigInt(l[e]);const a=new Array;let h,u=i;for(;u>=this.radix;)[u,h]=this.divmod(u,this.radix),a.unshift(parseInt(h,10));for(a.unshift(parseInt(u,10));a.length<this.bsDec;)a.unshift(0);let c="";a.forEach((t=>c=c.concat(e[t]))),r&&(c=r(c,o)),s=s.concat(c)}return[s,o]}decode(t,e,i=[],r=!0,n=!1){if(!t)return new Uint8Array(0);let s=this.bsDec;const a=[];let l;if([...t].forEach((t=>{const n=e.indexOf(t);if(n>-1)a.push(n);else if(r&&-1===i.indexOf(t))throw new o(t)})),0===s)s=a.length;else{l=(s-a.length%s)%s;const t=new Array(l).fill(this.decPadVal);n?a.unshift(...t):a.push(...t)}let h=new Array;for(let t=0,e=a.length;t<e;t+=s){let e=0n;for(let i=0;i<s;i++){const r=s-1-i,n=this.powers[r]||(()=>(this.powers[r]=BigInt(this.pow(r)),this.powers[r]))();e+=BigInt(a[t+i])*n}const i=[];let r,n=e;for(;n>=256;)[n,r]=this.divmod(n,256),i.unshift(parseInt(r,10));for(i.unshift(parseInt(n,10));i.length<this.bsEnc;)i.unshift(0);h.push(...i)}if(n){if(h.length>1){for(;!h[0];)h.shift();h.length||h.push(0),h.reverse()}}else if(this.bsDec){const t=this.padChars(l);h.splice(h.length-t)}return Uint8Array.from(h)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class h{constructor(t=!0){this.charsets={},this.decimalMode=!1,this.frozenCharsets=!1,this.hasDecimalMode=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.signed=!1,this.upper=null,t&&(this.utils=new a(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,i,...r){const n=this.utils.validateArgs(r);let[s,o,a]=this.utils.inputHandler.toBytes(t,n),l=null;e&&(l=e(n));let[h,u]=this.converter.encode(s,this.charsets[n.version],n.littleEndian,l);return n.signed&&(h=this.utils.toSignedStr(h,o)),n.upper&&(h=h.toUpperCase()),i&&(h=i({inputBytes:s,output:h,settings:n,zeroPadding:u,type:a})),this.utils.wrapOutput(h,n.options.lineWrap)}decode(t,e,i,r,...n){const s=this.utils.validateArgs(n);t=this.utils.normalizeInput(t,r);let o=!1;this.hasSignedMode&&([t,o]=this.utils.extractSign(t),o&&!s.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:s}));let a=this.converter.decode(t,this.charsets[s.version],this.padChars[s.version],s.integrity,s.littleEndian);return i&&(a=i({input:t,output:a,settings:s})),this.utils.outputHandler.compile(a,s.outputType,s.littleEndian,o)}}let u=1e6,c="[big.js] ",f=c+"Invalid ",d=f+"decimal places",p=f+"rounding mode",g={},y=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function w(t,e,i,r){let n=t.c;if(void 0===i&&(i=t.constructor.RM),0!==i&&1!==i&&2!==i&&3!==i)throw Error(p);if(e<1)r=3===i&&(r||!!n[0])||0===e&&(1===i&&n[0]>=5||2===i&&(n[0]>5||5===n[0]&&(r||void 0!==n[1]))),n.length=1,r?(t.e=t.e-e+1,n[0]=1):n[0]=t.e=0;else if(e<n.length){if(r=1===i&&n[e]>=5||2===i&&(n[e]>5||5===n[e]&&(r||void 0!==n[e+1]||1&n[e-1]))||3===i&&(r||!!n[0]),n.length=e,r)for(;++n[--e]>9;)if(n[e]=0,0===e){++t.e,n.unshift(1);break}for(e=n.length;!n[--e];)n.pop()}return t}function b(t,e,i){let r=t.e,n=t.c.join(""),s=n.length;if(e)n=n.charAt(0)+(s>1?"."+n.slice(1):"")+(r<0?"e":"e+")+r;else if(r<0){for(;++r;)n="0"+n;n="0."+n}else if(r>0)if(++r>s)for(r-=s;r--;)n+="0";else r<s&&(n=n.slice(0,r)+"."+n.slice(r));else s>1&&(n=n.charAt(0)+"."+n.slice(1));return t.s<0&&i?"-"+n:n}g.abs=function(){let t=new this.constructor(this);return t.s=1,t},g.cmp=function(t){let e,i=this,r=i.c,n=(t=new i.constructor(t)).c,s=i.s,o=t.s,a=i.e,l=t.e;if(!r[0]||!n[0])return r[0]?s:n[0]?-o:0;if(s!=o)return s;if(e=s<0,a!=l)return a>l^e?1:-1;for(o=(a=r.length)<(l=n.length)?a:l,s=-1;++s<o;)if(r[s]!=n[s])return r[s]>n[s]^e?1:-1;return a==l?0:a>l^e?1:-1},g.eq=function(t){return 0===this.cmp(t)},g.gt=function(t){return this.cmp(t)>0},g.gte=function(t){return this.cmp(t)>-1},g.lt=function(t){return this.cmp(t)<0},g.lte=function(t){return this.cmp(t)<1},g.minus=g.sub=function(t){let e,i,r,n,s=this,o=s.constructor,a=s.s,l=(t=new o(t)).s;if(a!=l)return t.s=-l,s.plus(t);let h=s.c.slice(),u=s.e,c=t.c,f=t.e;if(!h[0]||!c[0])return c[0]?t.s=-l:h[0]?t=new o(s):t.s=1,t;if(a=u-f){for((n=a<0)?(a=-a,r=h):(f=u,r=c),r.reverse(),l=a;l--;)r.push(0);r.reverse()}else for(i=((n=h.length<c.length)?h:c).length,a=l=0;l<i;l++)if(h[l]!=c[l]){n=h[l]<c[l];break}if(n&&(r=h,h=c,c=r,t.s=-t.s),(l=(i=c.length)-(e=h.length))>0)for(;l--;)h[e++]=0;for(l=e;i>a;){if(h[--i]<c[i]){for(e=i;e&&!h[--e];)h[e]=9;--h[e],h[i]+=10}h[i]-=c[i]}for(;0===h[--l];)h.pop();for(;0===h[0];)h.shift(),--f;return h[0]||(t.s=1,h=[f=0]),t.c=h,t.e=f,t},g.plus=g.add=function(t){let e,i,r,n=this,s=n.constructor;if(t=new s(t),n.s!=t.s)return t.s=-t.s,n.minus(t);let o=n.e,a=n.c,l=t.e,h=t.c;if(!a[0]||!h[0])return h[0]||(a[0]?t=new s(n):t.s=n.s),t;if(a=a.slice(),e=o-l){for(e>0?(l=o,r=h):(e=-e,r=a),r.reverse();e--;)r.push(0);r.reverse()}for(a.length-h.length<0&&(r=h,h=a,a=r),e=h.length,i=0;e;a[e]%=10)i=(a[--e]=a[e]+h[e]+i)/10|0;for(i&&(a.unshift(i),++l),e=a.length;0===a[--e];)a.pop();return t.c=a,t.e=l,t},g.round=function(t,e){if(void 0===t)t=0;else if(t!==~~t||t<-u||t>u)throw Error(d);return w(new this.constructor(this),t+this.e+1,e)},g.toFixed=function(t,e){let i=this,r=i.c[0];if(void 0!==t){if(t!==~~t||t<0||t>u)throw Error(d);for(i=w(new i.constructor(i),t+i.e+1,e),t=t+i.e+1;i.c.length<t;)i.c.push(0)}return b(i,!1,!!r)},g[Symbol.for("nodejs.util.inspect.custom")]=g.toJSON=g.toString=function(){let t=this,e=t.constructor;return b(t,t.e<=e.NE||t.e>=e.PE,!!t.c[0])},g.toNumber=function(){let t=Number(b(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(t.toString()))throw Error(c+"Imprecise conversion");return t};const m=function t(){function e(i){let r=this;if(!(r instanceof e))return void 0===i?t():new e(i);if(i instanceof e)r.s=i.s,r.e=i.e,r.c=i.c.slice();else{if("string"!=typeof i){if(!0===e.strict&&"bigint"!=typeof i)throw TypeError(f+"value");i=0===i&&1/i<0?"-0":String(i)}!function(t,e){let i,r,n;if(!y.test(e))throw Error(`${f}number`);for(t.s="-"==e.charAt(0)?(e=e.slice(1),-1):1,(i=e.indexOf("."))>-1&&(e=e.replace(".","")),(r=e.search(/e/i))>0?(i<0&&(i=r),i+=+e.slice(r+1),e=e.substring(0,r)):i<0&&(i=e.length),n=e.length,r=0;r<n&&"0"==e.charAt(r);)++r;if(r==n)t.c=[t.e=0];else{for(;n>0&&"0"==e.charAt(--n););for(t.e=i-r-1,t.c=[],i=0;r<=n;)t.c[i++]=+e.charAt(r++)}}(r,i)}r.constructor=e}return e.prototype=g,e.DP=20,e.RM=1,e.NE=-7,e.PE=21,e.strict=false,e.roundDown=0,e.roundHalfUp=1,e.roundHalfEven=2,e.roundUp=3,e}();
/**
 * [BaseEx|BasePhi Converter]{@link https://github.com/UmamiAppearance/BaseExJS/blob/main/src/converters/base-phi.js}
 *
 * @version 0.7.9
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license MIT
 */class E extends h{#r=m("1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752");constructor(...t){super(),this.converter={radix:2,bsEnc:0,bsDec:0},this.b10=new l(10,0,0),this.charsets.default=["0","1"],this.version="default",this.signed=!0,this.hasDecimalMode=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e),r=this.charsets[i.version];let n,s,o,a="";if(i.decimalMode){if(!Number.isFinite(t))throw new TypeError("When running the converter in decimal-mode, only input of type 'Number' is allowed.");t<0?(s=!0,o=m(-t)):(s=!1,o=m(t))}else[n,s]=this.utils.inputHandler.toBytes(t,i),o=m(this.b10.encode(n,null,i.littleEndian)[0]);if(o.eq(0)||o.eq(1))return a=r[o.toNumber()],s&&(a=`-${a}`),a;const l=[],h=[];let u=m(1),c=this.#r,f=0;for(;c.lt(o);)[u,c]=this.#n(u,c),f++;const d=(t,e,i)=>{if(!this.#s(o)){for(;t.gt(o);){if([t,e]=this.#o(t,e),t.lte(0))return void console.warn("Could not find an exact base-phi representation. Value is approximated.");i--}i>-1?l.unshift(i):h.push(i),o=o.minus(t),d(t,e,i)}};return d(u,c,f),f=0,l.forEach((t=>{for(;f<t;)a=`${r[0]}${a}`,f++;a=`${r[1]}${a}`,f++})),a?a+=".":a="0.",f=-1,h.forEach((t=>{for(;f>t;)a+=r[0],f--;a+=r[1],f--})),s&&(a=`-${a}`),a}decode(t,...e){const i=this.utils.validateArgs(e),r=this.charsets[i.version];let n;if([t,n]=this.utils.extractSign(this.utils.normalizeInput(t)),!i.integrity){const e=[...r,"."];t=[...t].filter((t=>e.includes(t))).join("")}const s=t.split(".");if(i.integrity&&s.length>2)throw new o(null,"There are multiple decimal points in the input.");const[a,l]=s;let h=m(0),u=this.#r.minus(1),c=m(1);if([...a].reverse().forEach((t=>{const e=r.indexOf(t);if(1===e)h=h.plus(c);else if(0!==e)throw new o(t);[u,c]=this.#n(u,c)})),l){let t=m(1);c=this.#r.minus(t),[...l].forEach((e=>{const i=r.indexOf(e);if(1===i)h=h.plus(c);else if(0!==i)throw new o(e);[c,t]=this.#o(c,t)}))}if(i.decimalMode)return h.toNumber();h=h.round().toFixed();const f=this.b10.decode(h,[..."0123456789"],[],i.integrity,i.littleEndian);return this.utils.outputHandler.compile(f,i.outputType,i.littleEndian,n)}#s(t){return!t.round(50).abs().toNumber()}#n(t,e){return[e,t.plus(e)]}#o(t,e){return[e.minus(t),t]}}export{E as default};
