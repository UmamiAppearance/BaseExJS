class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,s){let i;return i="buffer"===(s=e.getType(s))?t.buffer:"view"===s?new DataView(t.buffer):t,i}}class s{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const s=this.makeDataView(8);return s.setFloat64(0,t,e),s}static numbers(t,e=!1){let s,i;if(Number.isInteger(t)){if(i="int",!Number.isSafeInteger(t)){let e,s,i;throw t<0?(e=Number.MIN_SAFE_INTEGER,s="smaller",i="MIN"):(e=Number.MAX_SAFE_INTEGER,s="bigger",i="MAX"),new RangeError(`The provided integer is ${s} than ${i}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(s=this.makeDataView(8),s.setBigInt64(0,BigInt(t),e)):t<-32768?(s=this.makeDataView(4),s.setInt32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):t>0?t>4294967295?(s=this.makeDataView(8),s.setBigUint64(0,BigInt(t),e)):t>65535?(s=this.makeDataView(4),s.setUint32(0,t,e)):(s=this.makeDataView(2),s.setInt16(0,t,e)):s=new Uint16Array([0])}else i="float",s=this.floatingPoints(t,e);return[new Uint8Array(s.buffer),i]}static bigInts(t,e=!1){const s=new Array,i=e?"push":"unshift",n=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)s[i](t%n),t>>=64n;else for(;t>=n;)s[i](t%n),t>>=64n;s[i](t);const r=8*s.length,a=this.makeDataView(r);return s.forEach(((t,s)=>{const i=8*s;a.setBigUint64(i,t,e)})),new Uint8Array(a.buffer)}static toBytes(t,e){let s,i=!1,n="bytes";if(t instanceof ArrayBuffer)s=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))s=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)s=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(i=!0,t=-t),e.numberMode){const i=this.floatingPoints(t,e.littleEndian);s=new Uint8Array(i.buffer),n="float"}else[s,n]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(i=!0,t*=-1n),s=this.bigInts(t,e.littleEndian),n="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const i=new Array;for(const s of t)i.push(...this.toBytes(s,e)[0]);s=Uint8Array.from(i)}}return[s,i,n]}}class i{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,s,i){const n=t.byteLength,r=(e-t.byteLength%e)%e,a=i&&n>1?255:0;let o=t;if(r){o=new Uint8Array(n+r),o.fill(a);const e=s?0:r;o.set(t,e)}return o.buffer}static makeTypedArray(t,e,s,i){let n;if("int16"===e||"uint16"===e){const r=this.makeTypedArrayBuffer(t,2,s,i);n="int16"===e?new Int16Array(r):new Uint16Array(r)}else if("int32"===e||"uint32"===e||"float32"===e){const r=this.makeTypedArrayBuffer(t,4,s,i);n="int32"===e?new Int32Array(r):"uint32"===e?new Uint32Array(r):new Float32Array(r)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const r=this.makeTypedArrayBuffer(t,8,s,i);n="bigint64"===e?new BigInt64Array(r):"biguint64"===e?new BigUint64Array(r):new Float64Array(r)}return n}static compile(t,e,i=!1,n=!1){let r;if(e=this.getType(e),n){let n;if(n=e.match(/^float/)?-this.compile(t,"float_n",i):-this.compile(t,"uint_n",i),"float_n"===e)return n;t=s.toBytes(n,{littleEndian:i,numberMode:!1,signed:!1})[0]}if("buffer"===e)r=t.buffer;else if("bytes"===e||"uint8"===e)r=t;else if("int8"===e)r=new Int8Array(t.buffer);else if("view"===e)r=new DataView(t.buffer);else if("str"===e)r=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,i,n);t=new Uint8Array(e)}i&&t.reverse();let s=0n;t.forEach((t=>s=(s<<8n)+BigInt(t))),"uint_n"!==e&&(s=BigInt.asIntN(8*t.length,s)),r="bigint_n"!==e&&s>=Number.MIN_SAFE_INTEGER&&s<=Number.MAX_SAFE_INTEGER?Number(s):s}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,n);r=new DataView(e.buffer).getFloat32(0,i)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,n);r=new DataView(e.buffer).getFloat64(0,i)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);r=Number(e)}else r=this.makeTypedArray(t,e,i,n);return r}}const n=s,r=i;class a extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class o{constructor(t,e=!0){this.root=t,"charsets"in t&&e&&this.#t()}setIOHandlers(t=n,e=r){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e)=>{if("string"!=typeof t)throw new TypeError("The charset name must be a string.");const s=this.root.converter.radix;let i=s;if("string"==typeof e||Array.isArray(e))i=e.length,e=new Set(e);else if(!(e instanceof Set))throw new TypeError("The charset must be one of the types:\n'str', 'set', 'array'.");if(e.size!==s)throw i===s?new Error("There were repetitive chars found in your charset. Make sure each char is unique."):new Error(`The length of the charset must be ${s}.`);e=[...e].join(""),this.root.charsets[t]=e,console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{({version:t}=this.validateArgs([t])),this.root.version=t}}makeArgList(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}invalidArgument(t,e,s,i){const n=i?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",r=this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",a=this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",o=this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",l=this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",u=`\n * valid args for the output type are ${this.makeArgList(s)}`,h=e?`\n * the options for version (charset) are: ${this.makeArgList(e)}`:"";throw new TypeError(`'${t}'\n\nInput parameters:${n}${r}${a}${o}${l}${u}${h}\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)\n\nTraceback:`)}validateArgs(s,i=!1){const a={littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};if(!s.length)return i&&this.setIOHandlers(),a;const o=t=>!!s.includes(t)&&(s.splice(s.indexOf(t),1),!0),l=Object.prototype.hasOwnProperty.call(this.root,"charsets")?Object.keys(this.root.charsets):[],u={littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"]};if(i)if(o("bytes_only"))this.setIOHandlers(t,e);else{const s=o("bytes_in")?t:n,i=o("bytes_out")?e:r;this.setIOHandlers(s,i)}const h=this.outputHandler.typeList;if(o("number")&&(a.numberMode=!0,a.outputType="float_n"),s.forEach((t=>{if(t=String(t).toLowerCase(),l.includes(t))a.version=t;else if(h.includes(t))a.outputType=t;else{let e=!0;for(const s in u)if(u[s].includes(t)){if(e=!1,!this.root.isMutable[s])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);a[s]=Boolean(u[s].indexOf(t))}e&&this.invalidArgument(t,l,h,i)}})),a.padding&&a.signed&&(a.padding=!1,console.warn("Padding was set to false due to the signed conversion.")),i)for(const t in a)this.root[t]=a[t];return a}signError(){throw new a}}class l{constructor(t,e=null,s=null,i=0){this.radix=t,null!==e&&null!==s?(this.bsEnc=e,this.bsDec=s):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=i}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let s=0;for(;8*s*Math.log(2)/Math.log(t)<e;)s++;return[s,Math.ceil(8*s*Math.log(2)/Math.log(t))]}encode(t,e,s=!1,i=null){let n=this.bsEnc;0===n&&(n=t.byteLength);let r="";const a=n?(n-t.length%n)%n:0,o=new Array(a).fill(0);let l;if(s?(t.reverse(),l=[...o,...t]):l=[...t,...o],10===this.radix){let t=0n;for(let e=0;e<n;e++)t=(t<<8n)+BigInt(l[e]);return[t.toString(),0]}for(let t=0,s=l.length;t<s;t+=n){let s=0n;for(let e=t;e<t+n;e++)s=(s<<8n)+BigInt(l[e]);const o=new Array;let u,h=s;for(;h>=this.radix;)[h,u]=this.divmod(h,this.radix),o.unshift(parseInt(u,10));for(o.unshift(parseInt(h,10));o.length<this.bsDec;)o.unshift(0);let c="";o.forEach((t=>c=c.concat(e[t]))),i&&(c=i(c,a)),r=r.concat(c)}return[r,a]}decode(t,e,s=!1){if(!t)return new Uint8Array(0);let i=this.bsDec;const n=new Array;let r;if([...t].forEach((t=>{const s=e.indexOf(t);s>-1&&n.push(s)})),0===i)i=n.length;else{r=(i-n.length%i)%i;const t=new Array(r).fill(this.decPadVal);s?n.unshift(...t):n.push(...t)}let a=new Array;for(let t=0,e=n.length;t<e;t+=i){let e=0n;for(let s=0;s<i;s++)e+=BigInt(n[t+s])*this.pow(i-1-s);const s=new Array;let r,o=e;for(;o>=256;)[o,r]=this.divmod(o,256),s.unshift(parseInt(r,10));for(s.unshift(parseInt(o,10));s.length<this.bsEnc;)s.unshift(0);a=a.concat(s)}if(s){if(a.length>1){for(;!a[0];)a.shift();a.length||a.push(0),a.reverse()}}else if(this.bsDec){const t=this.padChars(r);a.splice(a.length-t)}return Uint8Array.from(a)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class u{constructor(t=!0){this.charsets={},this.hasSignedMode=!1,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.signed=!1,this.upper=null,t&&(this.utils=new o(this)),this.version="default",this.isMutable={littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,s,...i){const n=this.utils.validateArgs(i);let r,a,o;[r,a,o]=this.utils.inputHandler.toBytes(t,n);let l=null;e&&(l=e(n));let[u,h]=this.converter.encode(r,this.charsets[n.version],n.littleEndian,l);return n.signed&&(u=this.utils.toSignedStr(u,a)),n.upper&&(u=u.toUpperCase()),s&&(u=s({inputBytes:r,output:u,settings:n,zeroPadding:h,type:o})),u}decode(t,e,s,...i){const n=this.utils.validateArgs(i);t=String(t);let r=!1;this.hasSignedMode&&([t,r]=this.utils.extractSign(t),r&&!n.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:n}));let a=this.converter.decode(t,this.charsets[n.version],n.littleEndian);return s&&(a=s({input:t,output:a,settings:n})),this.utils.outputHandler.compile(a,n.outputType,n.littleEndian,r)}}class h extends u{constructor(...t){super(),delete this.addCharset,this.charsets.all=" !\"#$%&'()*+,./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",this.charsets.sequence="Hello World!",this.charsets.default="1",this.charsets.tmark="|#",this.converter=new l(10,0,0),this.hasSignedMode=!0,this.littleEndian=!0,this.signed=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;[i,n]=this.utils.inputHandler.toBytes(t,s);let r=this.converter.encode(i,null,s.littleEndian)[0],a=BigInt(r);if(a>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");a>16777216&&console.warn("The string length is really long. The JavaScript engine may have memory issues generating the output string."),a=Number(a);const o=this.charsets[s.version],l=o.length;let u="";if(1===l)u=o.repeat(a);else if("all"===s.version)for(let t=0;t<a;t++){u+=o[Math.floor(Math.random()*l)]}else if("tmark"===s.version){const t=a%5;a>4&&(u=o[1].repeat((a-t)/5)),u+=o[0].repeat(t)}else for(let t=0;t<a;t++)u+=o[t%l];return u=this.utils.toSignedStr(u,n),s.upper&&(u=u.toUpperCase()),u}decode(t,...e){const s=this.utils.validateArgs(e);let i;if(t=String(t),[t,i]=this.utils.extractSign(t),"all"!==s.version){const e=[...new Set(this.charsets[s.version])].join(""),i=new RegExp(`[^${e}]`,"g");t=t.replace(i,"")}t=String(t.length);const n=this.converter.decode(t,"0123456789",s.littleEndian);return this.utils.outputHandler.compile(n,s.outputType,s.littleEndian,i)}}class c extends u{constructor(...t){super(),this.converter=new l(16,1,2),this.charsets.default=[..."0123456789abcdef"],this.hasSignedMode=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;return e=e.replace(/^0x/,""),e.length%2&&(e="0".concat(e)),e}),null,...e)}}class d extends u{constructor(...t){super(),this.charsets.crockford=[..."0123456789abcdefghjkmnpqrstvwxyz"],this.charsets.rfc3548=[..."abcdefghijklmnopqrstuvwxyz234567"],this.charsets.rfc4648=[..."0123456789abcdefghijklmnopqrstuv"],this.charsets.zbase32=[..."ybndrfg8ejkmcpqxot1uwisza345h769"],this.converter=new l(32,5,8),this.hasSignedMode=!0,this.padding=!0,this.version="rfc4648",this.isMutable.littleEndian=!0,this.isMutable.padding=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(!s.littleEndian&&i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat("=".repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class f extends u{constructor(...t){super(),this.charsets.default=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],this.charsets.bitcoin=[..."123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],this.charsets.flickr=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],this.converter=new l(58,0,0),this.padding=!0,this.version="bitcoin",this.isMutable.padding=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{inputBytes:e,output:s,settings:i,type:n}=t;if(i.padding&&"int"!==n){let t=0;const i=e.length;if(i){for(;!e[t];)if(t++,t===i){t=0;break}const n=t;n&&(s="1".repeat(n).concat(s))}}return s}),...e)}decode(t,...e){return super.decode(t,null,(t=>{let{input:e,output:s,settings:i}=t;if(i.padding&&e.length>1){let t=0;for(;"1"===e[t];)t++;const i=t;i&&(s=Uint8Array.from([...new Array(i).fill(0),...s]))}return s}),...e)}}class p extends u{constructor(...t){super();const e=[..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"];this.charsets.default=e.concat(["+","/"]),this.charsets.urlsafe=e.concat(["-","_"]),this.converter=new l(64,3,4),this.padding=!0,this.isMutable.padding=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t),s.padding&&(e=e.concat("=".repeat(t)))}return e}),...e)}decode(t,...e){return super.decode(t,null,null,...e)}}class g extends u{constructor(...t){super(),this.charsets.adobe=[..."!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"],this.charsets.ascii85=this.charsets.adobe,this.charsets.rfc1924=[..."0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"],this.charsets.z85=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"],this.converter=new l(85,4,5,84),this.version="ascii85",this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,(t=>{let e;return t.version.match(/adobe|ascii85/)&&(e=(t,e)=>e||"!!!!!"!==t?t:"z"),e}),(t=>{let{output:e,settings:s,zeroPadding:i}=t;if(i){const t=this.converter.padBytes(i);e=e.slice(0,e.length-t)}return"adobe"===s.version&&(e=`<~${e}~>`),e}),...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e,settings:s}=t;return s.version.match(/adobe|ascii85/)&&(e=e.replace(/z/g,"!!!!!"),"adobe"===s.version&&(e=e.replace(/^<~|~>$/g,""))),e}),null,...e)}}class b extends u{constructor(...t){super(),this.charsets.default=[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'],this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e),i=this.utils.inputHandler.toBytes(t,s)[0];let n=0,r=0,a="";const o=this.charsets[s.version];if(i.forEach((t=>{if(r+=t<<n,n+=8,n>13){let t,e,s=13,i=r%8192;i<89&&(s=14,i=r%16384),r>>=s,n-=s,[t,e]=this.divmod(i,91),a=`${a}${o[e]}${o[t]}`}})),n){let t,e;[t,e]=this.divmod(r,91),a=a.concat(o[e]),(n>7||r>90)&&(a=a.concat(o[t]))}return a}decode(t,...e){const s=this.utils.validateArgs(e);let i=(t=String(t)).length,n=!1;i%2&&(n=!0,i--);let r=0,a=0;const o=this.charsets[s.version],l=new Array;for(let e=0;e<i;e+=2){const s=o.indexOf(t[e])+91*o.indexOf(t[e+1]);r=(s<<a)+r,a+=s%8192>88?13:14;do{l.push(r%256),r>>=8,a-=8}while(a>7)}if(n){const e=t.charAt(i),s=o.indexOf(e);l.push(((s<<a)+r)%256)}const u=Uint8Array.from(l);return this.utils.outputHandler.compile(u,s.outputType)}divmod(t,e){return[Math.floor(t/e),t%e]}}class y{constructor(...t){this.littleEndian=!0,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(t,e=!1)=>{const s={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!t.length)return s;t.includes("number")&&(t.splice(t.indexOf("number"),1),s.numberMode=!0,s.outputType="float_n");const n=i.typeList.map((t=>`'${t}'`)).join(", ");if(t.forEach((t=>{if("le"===(t=String(t).toLowerCase()))s.littleEndian=!0;else if("be"===t)s.littleEndian=!1;else{if(!i.typeList.includes(t))throw new TypeError(`Invalid argument: '${t}.\nValid arguments are:\n'le', 'be', ${n}`);s.outputType=t}})),e)for(const t in s)this[t]=s[t];return s}},this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e);return s.toBytes(t,i)[0]}decode(t,...e){const s=this.utils.validateArgs(e);return i.compile(t,s.outputType,s.littleEndian)}}class w extends u{constructor(...t){super(),this.converter=new l(1024,5,4),this.padding=!0,this.version="emojisV1",this.charsets.emojisV1=[..."ðŸ€„ðŸƒðŸ…°ðŸ…±ðŸ…¾ðŸ…¿ðŸ†ŽðŸ†‘ðŸ†’ðŸ†“ðŸ†”ðŸ†•ðŸ†–ðŸ†—ðŸ†˜ðŸ†™ðŸ†šðŸ‡¦ðŸ‡§ðŸ‡¨ðŸ‡©ðŸ‡ªðŸ‡«ðŸ‡¬ðŸ‡­ðŸ‡®ðŸ‡¯ðŸ‡°ðŸ‡±ðŸ‡²ðŸ‡³ðŸ‡´ðŸ‡µðŸ‡¶ðŸ‡·ðŸ‡¸ðŸ‡¹ðŸ‡ºðŸ‡»ðŸ‡¼ðŸ‡½ðŸ‡¾ðŸ‡¿ðŸˆðŸˆ‚ðŸˆšðŸˆ¯ðŸˆ²ðŸˆ³ðŸˆ´ðŸˆµðŸˆ¶ðŸˆ·ðŸˆ¸ðŸˆ¹ðŸˆºðŸ‰ðŸ‰‘ðŸŒ€ðŸŒðŸŒ‚ðŸŒƒðŸŒ„ðŸŒ…ðŸŒ†ðŸŒ‡ðŸŒˆðŸŒ‰ðŸŒŠðŸŒ‹ðŸŒŒðŸŒðŸŒŽðŸŒðŸŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒ™ðŸŒšðŸŒ›ðŸŒœðŸŒðŸŒžðŸŒŸðŸŒ ðŸŒ¡ðŸŒ¤ðŸŒ¥ðŸŒ¦ðŸŒ§ðŸŒ¨ðŸŒ©ðŸŒªðŸŒ«ðŸŒ¬ðŸŒ­ðŸŒ®ðŸŒ¯ðŸŒ°ðŸŒ±ðŸŒ²ðŸŒ³ðŸŒ´ðŸŒµðŸŒ¶ðŸŒ·ðŸŒ¸ðŸŒ¹ðŸŒºðŸŒ»ðŸŒ¼ðŸŒ½ðŸŒ¾ðŸŒ¿ðŸ€ðŸðŸ‚ðŸƒðŸ„ðŸ…ðŸ†ðŸ‡ðŸˆðŸ‰ðŸŠðŸ‹ðŸŒðŸðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—ðŸ˜ðŸ™ðŸšðŸ›ðŸœðŸðŸžðŸŸðŸ ðŸ¡ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµðŸ¶ðŸ·ðŸ¸ðŸ¹ðŸºðŸ»ðŸ¼ðŸ½ðŸ¾ðŸ¿ðŸŽ€ðŸŽðŸŽ‚ðŸŽƒðŸŽ„ðŸŽ…ðŸŽ†ðŸŽ‡ðŸŽˆðŸŽ‰ðŸŽŠðŸŽ‹ðŸŽŒðŸŽðŸŽŽðŸŽðŸŽðŸŽ‘ðŸŽ’ðŸŽ“ðŸŽ–ðŸŽ—ðŸŽ™ðŸŽšðŸŽ›ðŸŽžðŸŽŸðŸŽ ðŸŽ¡ðŸŽ¢ðŸŽ£ðŸŽ¤ðŸŽ¥ðŸŽ¦ðŸŽ§ðŸŽ¨ðŸŽ©ðŸŽªðŸŽ«ðŸŽ¬ðŸŽ­ðŸŽ®ðŸŽ¯ðŸŽ°ðŸŽ±ðŸŽ²ðŸŽ³ðŸŽ´ðŸŽµðŸŽ¶ðŸŽ·ðŸŽ¸ðŸŽ¹ðŸŽºðŸŽ»ðŸŽ¼ðŸŽ½ðŸŽ¾ðŸŽ¿ðŸ€ðŸðŸ‚ðŸƒðŸ„ðŸ…ðŸ†ðŸ‡ðŸˆðŸ‰ðŸŠðŸ‹ðŸŒðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—ðŸ˜ðŸ™ðŸšðŸ›ðŸœðŸðŸžðŸŸðŸ ðŸ¡ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ³ðŸ´ðŸµðŸ·ðŸ¸ðŸ¹ðŸºðŸ»ðŸ¼ðŸ½ðŸ¾ðŸ¿ðŸ€ðŸðŸ‚ðŸƒðŸ„ðŸ…ðŸ†ðŸ‡ðŸˆðŸ‰ðŸŠðŸ‹ðŸŒðŸðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—ðŸ˜ðŸ™ðŸšðŸ›ðŸœðŸðŸžðŸŸðŸ ðŸ¡ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµðŸ¶ðŸ·ðŸ¸ðŸ¹ðŸºðŸ»ðŸ¼ðŸ½ðŸ¾ðŸ¿ðŸ‘€ðŸ‘ðŸ‘‚ðŸ‘ƒðŸ‘„ðŸ‘…ðŸ‘†ðŸ‘‡ðŸ‘ˆðŸ‘‰ðŸ‘ŠðŸ‘‹ðŸ‘ŒðŸ‘ðŸ‘ŽðŸ‘ðŸ‘ðŸ‘‘ðŸ‘’ðŸ‘“ðŸ‘”ðŸ‘•ðŸ‘–ðŸ‘—ðŸ‘˜ðŸ‘™ðŸ‘šðŸ‘›ðŸ‘œðŸ‘ðŸ‘žðŸ‘ŸðŸ‘ ðŸ‘¡ðŸ‘¢ðŸ‘£ðŸ‘¤ðŸ‘¥ðŸ‘¦ðŸ‘§ðŸ‘¨ðŸ‘©ðŸ‘ªðŸ‘«ðŸ‘¬ðŸ‘­ðŸ‘®ðŸ‘¯ðŸ‘°ðŸ‘±ðŸ‘²ðŸ‘³ðŸ‘´ðŸ‘µðŸ‘¶ðŸ‘·ðŸ‘¸ðŸ‘¹ðŸ‘ºðŸ‘»ðŸ‘¼ðŸ‘½ðŸ‘¾ðŸ‘¿ðŸ’€ðŸ’ðŸ’‚ðŸ’ƒðŸ’„ðŸ’…ðŸ’†ðŸ’‡ðŸ’ˆðŸ’‰ðŸ’ŠðŸ’‹ðŸ’ŒðŸ’ðŸ’ŽðŸ’ðŸ’ðŸ’‘ðŸ’’ðŸ’“ðŸ’”ðŸ’•ðŸ’–ðŸ’—ðŸ’˜ðŸ’™ðŸ’šðŸ’›ðŸ’œðŸ’ðŸ’žðŸ’ŸðŸ’ ðŸ’¡ðŸ’¢ðŸ’£ðŸ’¤ðŸ’¥ðŸ’¦ðŸ’§ðŸ’¨ðŸ’©ðŸ’ªðŸ’«ðŸ’¬ðŸ’­ðŸ’®ðŸ’¯ðŸ’°ðŸ’±ðŸ’²ðŸ’³ðŸ’´ðŸ’µðŸ’¶ðŸ’·ðŸ’¸ðŸ’¹ðŸ’ºðŸ’»ðŸ’¼ðŸ’½ðŸ’¾ðŸ’¿ðŸ“€ðŸ“ðŸ“‚ðŸ“ƒðŸ“„ðŸ“…ðŸ“†ðŸ“‡ðŸ“ˆðŸ“‰ðŸ“ŠðŸ“‹ðŸ“ŒðŸ“ðŸ“ŽðŸ“ðŸ“ðŸ“’ðŸ““ðŸ“”ðŸ“•ðŸ“–ðŸ“—ðŸ“˜ðŸ“™ðŸ“šðŸ“›ðŸ“œðŸ“ðŸ“žðŸ“ŸðŸ“ ðŸ“¡ðŸ“¢ðŸ“£ðŸ“¤ðŸ“¥ðŸ“¦ðŸ“§ðŸ“¨ðŸ“©ðŸ“ªðŸ“«ðŸ“¬ðŸ“­ðŸ“®ðŸ“¯ðŸ“°ðŸ“±ðŸ“²ðŸ“³ðŸ“´ðŸ“µðŸ“¶ðŸ“·ðŸ“¸ðŸ“¹ðŸ“ºðŸ“»ðŸ“¼ðŸ“½ðŸ“¿ðŸ”€ðŸ”ðŸ”‚ðŸ”ƒðŸ”„ðŸ”…ðŸ”†ðŸ”‡ðŸ”ˆðŸ”‰ðŸ”ŠðŸ”‹ðŸ”ŒðŸ”ðŸ”ŽðŸ”ðŸ”ðŸ”‘ðŸ”’ðŸ”“ðŸ””ðŸ”•ðŸ”–ðŸ”—ðŸ”˜ðŸ”™ðŸ”šðŸ”›ðŸ”œðŸ”ðŸ”žðŸ”ŸðŸ” ðŸ”¡ðŸ”¢ðŸ”£ðŸ”¤ðŸ”¥ðŸ”¦ðŸ”§ðŸ”¨ðŸ”©ðŸ”ªðŸ”«ðŸ”¬ðŸ”­ðŸ”®ðŸ”¯ðŸ”°ðŸ”±ðŸ”²ðŸ”³ðŸ”´ðŸ”µðŸ”¶ðŸ”·ðŸ”¸ðŸ”¹ðŸ”ºðŸ”»ðŸ”¼ðŸ”½ðŸ•‰ðŸ•ŠðŸ•‹ðŸ•ŒðŸ•ðŸ•ŽðŸ•ðŸ•‘ðŸ•’ðŸ•“ðŸ•”ðŸ••ðŸ•–ðŸ•—ðŸ•˜ðŸ•™ðŸ•šðŸ•›ðŸ•œðŸ•ðŸ•žðŸ•ŸðŸ• ðŸ•¡ðŸ•¢ðŸ•£ðŸ•¤ðŸ•¥ðŸ•¦ðŸ•§ðŸ•¯ðŸ•°ðŸ•³ðŸ•´ðŸ•µðŸ•¶ðŸ•·ðŸ•¸ðŸ•¹ðŸ•ºðŸ–‡ðŸ–ŠðŸ–‹ðŸ–ŒðŸ–ðŸ–ðŸ–•ðŸ––ðŸ–¤ðŸ–¥ðŸ–¨ðŸ–±ðŸ–²ðŸ–¼ðŸ—‚ðŸ—ƒðŸ—„ðŸ—‘ðŸ—’ðŸ—“ðŸ—œðŸ—ðŸ—žðŸ—¡ðŸ—£ðŸ—¨ðŸ—¯ðŸ—³ðŸ—ºðŸ—»ðŸ—¼ðŸ—½ðŸ—¾ðŸ—¿ðŸ˜€ðŸ˜ðŸ˜‚ðŸ˜ƒðŸ˜„ðŸ˜…ðŸ˜†ðŸ˜‡ðŸ˜ˆðŸ˜‰ðŸ˜ŠðŸ˜‹ðŸ˜ŒðŸ˜ðŸ˜ŽðŸ˜ðŸ˜ðŸ˜‘ðŸ˜’ðŸ˜“ðŸ˜”ðŸ˜•ðŸ˜–ðŸ˜—ðŸ˜˜ðŸ˜™ðŸ˜šðŸ˜›ðŸ˜œðŸ˜ðŸ˜žðŸ˜ŸðŸ˜ ðŸ˜¡ðŸ˜¢ðŸ˜£ðŸ˜¤ðŸ˜¥ðŸ˜¦ðŸ˜§ðŸ˜¨ðŸ˜©ðŸ˜ªðŸ˜«ðŸ˜¬ðŸ˜­ðŸ˜®ðŸ˜¯ðŸ˜°ðŸ˜±ðŸ˜²ðŸ˜³ðŸ˜´ðŸ˜µðŸ˜¶ðŸ˜·ðŸ˜¸ðŸ˜¹ðŸ˜ºðŸ˜»ðŸ˜¼ðŸ˜½ðŸ˜¾ðŸ˜¿ðŸ™€ðŸ™ðŸ™‚ðŸ™ƒðŸ™„ðŸ™…ðŸ™†ðŸ™‡ðŸ™ˆðŸ™‰ðŸ™ŠðŸ™ŒðŸ™ðŸ™ŽðŸ™ðŸš€ðŸšðŸš‚ðŸšƒðŸš„ðŸš…ðŸš†ðŸš‡ðŸšˆðŸš‰ðŸšŠðŸš‹ðŸšŒðŸšðŸšŽðŸšðŸšðŸš‘ðŸš’ðŸš“ðŸš”ðŸš•ðŸš–ðŸš—ðŸš˜ðŸš™ðŸššðŸš›ðŸšœðŸšðŸšžðŸšŸðŸš ðŸš¡ðŸš¢ðŸš£ðŸš¤ðŸš¥ðŸš¦ðŸš§ðŸš¨ðŸš©ðŸšªðŸš«ðŸš¬ðŸš­ðŸš®ðŸš¯ðŸš°ðŸš±ðŸš²ðŸš³ðŸš´ðŸšµðŸš¶ðŸš·ðŸš¸ðŸš¹ðŸšºðŸš»ðŸš¼ðŸš½ðŸš¾ðŸš¿ðŸ›€ðŸ›ðŸ›‚ðŸ›ƒðŸ›„ðŸ›…ðŸ›‹ðŸ›ŒðŸ›ðŸ›ŽðŸ›ðŸ›ðŸ›‘ðŸ›’ðŸ› ðŸ›¡ðŸ›¢ðŸ›£ðŸ›¤ðŸ›¥ðŸ›©ðŸ›«ðŸ›¬ðŸ›°ðŸ›³ðŸ›´ðŸ›µðŸ›¶ðŸ›·ðŸ›¸ðŸ›¹ðŸ¤ðŸ¤‘ðŸ¤’ðŸ¤“ðŸ¤”ðŸ¤•ðŸ¤–ðŸ¤—ðŸ¤˜ðŸ¤™ðŸ¤šðŸ¤›ðŸ¤œðŸ¤ðŸ¤žðŸ¤ŸðŸ¤ ðŸ¤¡ðŸ¤¢ðŸ¤£ðŸ¤¤ðŸ¤¥ðŸ¤¦ðŸ¤§ðŸ¤¨ðŸ¤©ðŸ¤ªðŸ¤«ðŸ¤¬ðŸ¤­ðŸ¤®ðŸ¤¯ðŸ¤°ðŸ¤±ðŸ¤²ðŸ¤³ðŸ¤´ðŸ¤µðŸ¤¶ðŸ¤·ðŸ¤¸ðŸ¤¹ðŸ¤ºðŸ¤¼ðŸ¤½ðŸ¤¾ðŸ¥€ðŸ¥ðŸ¥‚ðŸ¥ƒðŸ¥„ðŸ¥…ðŸ¥‡ðŸ¥ˆðŸ¥‰ðŸ¥ŠðŸ¥‹ðŸ¥ŒðŸ¥ðŸ¥ŽðŸ¥ðŸ¥ðŸ¥‘ðŸ¥’ðŸ¥“ðŸ¥”ðŸ¥•ðŸ¥–ðŸ¥—ðŸ¥˜ðŸ¥™ðŸ¥šðŸ¥›ðŸ¥œðŸ¥ðŸ¥žðŸ¥ŸðŸ¥ ðŸ¥¡ðŸ¥¢ðŸ¥£ðŸ¥¤ðŸ¥¥ðŸ¥¦ðŸ¥§ðŸ¥¨ðŸ¥©ðŸ¥ªðŸ¥«ðŸ¥¬ðŸ¥­ðŸ¥®ðŸ¥¯ðŸ¥°ðŸ¥³ðŸ¥´ðŸ¥µðŸ¥¶ðŸ¥ºðŸ¥¼ðŸ¥½ðŸ¥¾ðŸ¥¿ðŸ¦€ðŸ¦ðŸ¦‚ðŸ¦ƒðŸ¦„ðŸ¦…ðŸ¦†ðŸ¦‡ðŸ¦ˆðŸ¦‰ðŸ¦ŠðŸ¦‹ðŸ¦ŒðŸ¦ðŸ¦ŽðŸ¦ðŸ¦ðŸ¦‘ðŸ¦’ðŸ¦“ðŸ¦”ðŸ¦•ðŸ¦–ðŸ¦—ðŸ¦˜ðŸ¦™ðŸ¦šðŸ¦›ðŸ¦œðŸ¦ðŸ¦žðŸ¦ŸðŸ¦ ðŸ¦¡ðŸ¦¢ðŸ¦°ðŸ¦±ðŸ¦²ðŸ¦³ðŸ¦´ðŸ¦µðŸ¦¶ðŸ¦·ðŸ¦¸ðŸ¦¹ðŸ§€ðŸ§ðŸ§‚ðŸ§ðŸ§‘ðŸ§’ðŸ§“ðŸ§”ðŸ§•"],this.padChars={default:"â˜•",p4x:{emojisV1:["âšœ","ðŸ","ðŸ“‘","ðŸ™‹"],emojisV2:["ðŸ¥·","ðŸ›¼","ðŸ“‘","ðŸ™‹"]}},this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(t=>{let{output:e,settings:s,zeroPadding:i}=t;const n=this.charsets[s.version];let r=[...e];if(i>1){const t=this.converter.padBytes(i),e=new Array(t).fill(this.padChars.default);r.splice(r.length-t,t,...e)}else if(1===i){const t=n.indexOf(r.pop())>>8;r.push(this.padChars.p4x[s.version].at(t))}return r.join("")}),...e)}decode(t,...e){let s=!1;return super.decode(t,(t=>{let{input:e,settings:i}=t;const n=this.charsets[i.version],r=[...e],a=r.at(-1);for(let t=0;t<this.padChars.p4x.length;t++)if(a===this.padChars.p4x[i.version].at(t)){r.splice(-1,1,n.at(t<<8)),e=r.join(""),s=!0;break}return e}),(t=>{let{output:e}=t;return s&&(e=new Uint8Array(e.buffer.slice(0,-1))),e}),...e)}}class m extends u{constructor(...t){super(!1),this.charsets.default="<placeholder>",this.charsets.hex="<placeholder>",this.version="default",this.converter=new l(10,0,0),this.hexlify=new l(16,1,2),this.utils=new o(this,!1),this.littleEndian=!0,this.hasSignedMode=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);let i,n;const r=s.signed;s.signed=!0,[i,n]=this.utils.inputHandler.toBytes(t,s);let a=this.converter.encode(i,null,s.littleEndian)[0],o=BigInt(a),l=new Array;if(n){if(!r)throw new TypeError("Negative values in unsigned mode are invalid.");o=-o}if(r)for(;;){const t=Number(127n&o);if(o>>=7n,0==o&&0==(64&t)||-1==o&&0!=(64&t)){l.push(t);break}l.push(128|t)}else for(;;){const t=Number(127n&o);if(o>>=7n,0==o){l.push(t);break}l.push(128|t)}const u=Uint8Array.from(l);return"hex"===s.version?this.hexlify.encode(u,"0123456789abcdef",!1)[0]:u}decode(t,...e){const s=this.utils.validateArgs(e);if("hex"===s.version?t=this.hexlify.decode(String(t).toLowerCase(),"0123456789abcdef",!1):t instanceof ArrayBuffer&&(t=new Uint8Array(t)),1===t.length&&!t[0])return this.utils.outputHandler.compile(new Uint8Array(1),s.outputType,!0);t=Array.from(t);let i,n,r,a=0n,o=-7n;for(i of t)o+=7n,a+=BigInt(127&i)<<o;s.signed&&0!=(64&i)&&(a|=-(1n<<o+7n)),[n,r]=this.utils.extractSign(a.toString());const l=this.converter.decode(n,"0123456789",!0);return this.utils.outputHandler.compile(l,s.outputType,!0,r)}}class v extends u{constructor(t,...e){if(super(),!t||!Number.isInteger(t)||t<2||t>36)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 36.");this.charsets.default="0123456789abcdefghijklmnopqrstuvwxyz".substring(0,t),this.converter=new l(t,0,0),this.hasSignedMode=!0,this.littleEndian=!(2===t||16===t),this.signed=!0,this.version="default",this.isMutable.littleEndian=!0,this.isMutable.upper=!0,this.utils.validateArgs(e,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(t=>{let{input:e}=t;if(2===this.converter.radix){const t=(8-e.length%8)%8;e=`${"0".repeat(t)}${e}`}else if(16===this.converter.radix){const t=e.length%2;e=`${"0".repeat(t)}${e}`}return e}),null,...e)}}
/**
 * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
 *
 * @version 0.5.0
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license GPL-3.0 AND BSD-3-Clause (only regarding Base91, Copyright (c) 2000-2006 Joachim Henke)
 */class A{constructor(t="buffer"){if(!r.typeList.includes(t)){let e=`Invalid argument '${t}' for output type. Allowed types are:\n`;throw e=e.concat(r.typeList.join(", ")),new TypeError(e)}this.base1=new h("default",t),this.base16=new c("default",t),this.base32_crockford=new d("rfc4648",t),this.base32_rfc3548=new d("rfc3548",t),this.base32_rfc4648=new d("rfc4648",t),this.base32_zbase32=new d("zbase32",t),this.base58=new f("default",t),this.base58_bitcoin=new f("bitcoin",t),this.base58_flickr=new f("flickr",t),this.base64=new p("default",t),this.base64_urlsafe=new p("urlsafe",t),this.base85_adobe=new g("adobe",t),this.base85_ascii=new g("ascii85",t),this.base85_z85=new g("z85",t),this.base91=new b("default",t),this.leb128=new m("default",t),this.ecoji=new w("default"),this.byteConverter=new y(t),this.simpleBase={};for(let e=2;e<37;e++)this.simpleBase[`base${e}`]=new v(e,t)}}export{h as Base1,c as Base16,d as Base32,f as Base58,p as Base64,g as Base85,b as Base91,A as BaseEx,y as ByteConverter,w as Ecoji,m as LEB128,v as SimpleBase};
