class t{static toBytes(t){return ArrayBuffer.isView(t)&&(t=t.buffer),[new Uint8Array(t),!1,"bytes"]}}class e{static get typeList(){return["buffer","bytes","uint8","view"]}static getType(t){if(!e.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static compile(t,i){let s;return s="buffer"===(i=e.getType(i))?t.buffer:"view"===i?new DataView(t.buffer):t,s}}class i{static makeDataView(t){const e=new ArrayBuffer(t);return new DataView(e)}static floatingPoints(t,e=!1){const i=this.makeDataView(8);return i.setFloat64(0,t,e),i}static numbers(t,e=!1){let i,s;if(Number.isInteger(t)){if(s="int",!Number.isSafeInteger(t)){let e,i,s;throw t<0?(e=Number.MIN_SAFE_INTEGER,i="smaller",s="MIN"):(e=Number.MAX_SAFE_INTEGER,i="bigger",s="MAX"),new RangeError(`The provided integer is ${i} than ${s}_SAFE_INTEGER: '${e}'\nData integrity is not guaranteed. Use a BigInt to avoid this issue.\n(If you see this error although a float was provided, the input has to many digits before the decimal point to store the decimal places in a float with 64 bits.)`)}t<0?t<-2147483648?(i=this.makeDataView(8),i.setBigInt64(0,BigInt(t),e)):t<-32768?(i=this.makeDataView(4),i.setInt32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):t>0?t>4294967295?(i=this.makeDataView(8),i.setBigUint64(0,BigInt(t),e)):t>65535?(i=this.makeDataView(4),i.setUint32(0,t,e)):(i=this.makeDataView(2),i.setInt16(0,t,e)):i=new Uint16Array([0])}else s="float",i=this.floatingPoints(t,e);return[new Uint8Array(i.buffer),s]}static bigInts(t,e=!1){const i=new Array,s=e?"push":"unshift",r=18446744073709551616n;if(t<0)for(;t<-9223372036854775808n;)i[s](t%r),t>>=64n;else for(;t>=r;)i[s](t%r),t>>=64n;i[s](t);const n=8*i.length,o=this.makeDataView(n);return i.forEach(((t,i)=>{const s=8*i;o.setBigUint64(s,t,e)})),new Uint8Array(o.buffer)}static toBytes(t,e){let i,s=!1,r="bytes";if(t instanceof ArrayBuffer)i=new Uint8Array(t.slice());else if(ArrayBuffer.isView(t))i=new Uint8Array(t.buffer.slice());else if("string"==typeof t||t instanceof String)i=(new TextEncoder).encode(t);else if("number"==typeof t){if(isNaN(t))throw new TypeError("Cannot proceed. Input is NaN.");if(t==1/0)throw new TypeError("Cannot proceed. Input is Infinity.");if(e.signed&&t<0&&(s=!0,t=-t),e.numberMode){const s=this.floatingPoints(t,e.littleEndian);i=new Uint8Array(s.buffer),r="float"}else[i,r]=this.numbers(t,e.littleEndian)}else if("bigint"==typeof t)e.signed&&t<0&&(s=!0,t*=-1n),i=this.bigInts(t,e.littleEndian),r="int";else{if(!Array.isArray(t))throw new TypeError("The provided input type can not be processed.");{const s=new Array;for(const i of t)s.push(...this.toBytes(i,e)[0]);i=Uint8Array.from(s)}}return[i,s,r]}}class s{static get typeList(){return["bigint64","bigint_n","biguint64","buffer","bytes","float32","float64","float_n","int8","int16","int32","int_n","str","uint8","uint16","uint32","uint_n","view"]}static getType(t){if(!this.typeList.includes(t))throw new TypeError(`Unknown output type: '${t}'`);return t}static makeTypedArrayBuffer(t,e,i,s){const r=t.byteLength,n=(e-t.byteLength%e)%e,o=s&&r>1?255:0;let a=t;if(n){a=new Uint8Array(r+n),a.fill(o);const e=i?0:n;a.set(t,e)}return a.buffer}static makeTypedArray(t,e,i,s){let r;if("int16"===e||"uint16"===e){const n=this.makeTypedArrayBuffer(t,2,i,s);r="int16"===e?new Int16Array(n):new Uint16Array(n)}else if("int32"===e||"uint32"===e||"float32"===e){const n=this.makeTypedArrayBuffer(t,4,i,s);r="int32"===e?new Int32Array(n):"uint32"===e?new Uint32Array(n):new Float32Array(n)}else if("bigint64"===e||"biguint64"===e||"float64"===e){const n=this.makeTypedArrayBuffer(t,8,i,s);r="bigint64"===e?new BigInt64Array(n):"biguint64"===e?new BigUint64Array(n):new Float64Array(n)}return r}static compile(t,e,s=!1,r=!1){let n;if(e=this.getType(e),r){let r;if(r=e.match(/^float/)?-this.compile(t,"float_n",s):-this.compile(t,"uint_n",s),"float_n"===e)return r;t=i.toBytes(r,{littleEndian:s,numberMode:!1,signed:!1})[0]}if("buffer"===e)n=t.buffer;else if("bytes"===e||"uint8"===e)n=t;else if("int8"===e)n=new Int8Array(t.buffer);else if("view"===e)n=new DataView(t.buffer);else if("str"===e)n=(new TextDecoder).decode(t);else if("uint_n"===e||"int_n"===e||"bigint_n"===e){if(1===t.length){const e=this.makeTypedArrayBuffer(t,2,s,r);t=new Uint8Array(e)}s&&t.reverse();let i=0n;t.forEach((t=>i=(i<<8n)+BigInt(t))),"uint_n"!==e&&(i=BigInt.asIntN(8*t.length,i)),n="bigint_n"!==e&&i>=Number.MIN_SAFE_INTEGER&&i<=Number.MAX_SAFE_INTEGER?Number(i):i}else if("float_n"===e)if(t.length<=4){let e;e=4===t.length?t:this.makeTypedArray(t,"float32",!1,r);n=new DataView(e.buffer).getFloat32(0,s)}else{if(!(t.length<=8))throw new RangeError("The provided input is to complex to be converted into a floating point.");{let e;e=8===t.length?t:this.makeTypedArray(t,"float64",!1,r);n=new DataView(e.buffer).getFloat64(0,s)}}else if("number"===e){if(8!==t.length)throw new TypeError("Type mismatch. Cannot convert into number.");const e=new Float64Array(t.buffer);n=Number(e)}else n=this.makeTypedArray(t,e,s,r);return n}}const r=i,n=s;class o extends TypeError{constructor(){super("The input is signed but the converter is not set to treat input as signed.\nYou can pass the string 'signed' to the decode function or when constructing the converter."),this.name="SignError"}}class a extends TypeError{constructor(t,e=null){null===e&&(e=`Character '${t}' is not part of the charset.`),super(e),this.name="DecodingError"}}class h{constructor(t){this.root=t,this.converterArgs={},this.#t()}setIOHandlers(t=r,e=n){this.inputHandler=t,this.outputHandler=e}#t(){this.root.addCharset=(t,e,i=[],s=!0)=>{const r=(t,i,s)=>{if(0===s&&i.length)return console.warn(`This converter has no ${t}. The following argument was ignored:\n'${i}'`),[];let r=s;if("string"==typeof i&&(i=[...i]),Array.isArray(i))r=i.length,i=new Set(i);else if(!(i instanceof Set))throw new TypeError(`The ${t} must be one of the types:\n'str', 'set', 'array'."`);if(i.size===s)return[...i];if(r!==s)throw new Error(`Your ${t} has a length of ${r}. The converter requires a length of ${s}.`);{const i={};(e=[...e]).forEach((t=>{t in i?i[t]++:i[t]=1}));let r="";s<100&&(r=`${e.join("")}\n`,e.forEach((t=>{i[t]>1?r+="^":r+=" "})));const n=Object.keys(i).filter((t=>i[t]>1));throw new Error(`You have repetitive char(s) [ ${n.join(" | ")} ] in your ${t}. Make sure each character is unique.\n${r}`)}};if(this.root.frozenCharsets)throw new Error("The charsets of this converter cannot be changed.");if("string"!=typeof t)throw new TypeError("The charset name must be a string.");s&&t in this.root.charsets&&console.warn(`An existing charset with name ${t} will get replaced.`);const n=r("charset",e,this.root.converter.radix),o=r("padding set",i,this.root.padCharAmount);this.root.charsets[t]=n,o.length&&(this.root.padChars[t]=o),s&&console.info(`New charset '${t}' was added and is ready to use`)},this.root.setDefaultCharset=t=>{if(!(t in this.root.charsets)){const e=Object.keys(this.root.charsets).join("\n   * ");throw new TypeError(`Charset ${t} was not found. Available charsets are:\n   * ${e}`)}this.root.version=t}}#e(t){return t.map((t=>`'${t}'`)).join(", ")}toSignedStr(t,e){return t=t.replace(/^0+(?!$)/,""),e&&(t="-".concat(t)),t}extractSign(t){let e=!1;return"-"===t[0]&&(e=!0,t=t.slice(1)),[t,e]}#i(t,e,i,s){throw new TypeError([`'${t}'\n\nParameters:`,s?"\n * valid declarations for IO handlers are 'bytesOnly', 'bytesIn', 'bytesOut'":"",this.root.isMutable.signed?"\n * pass 'signed' to disable, 'unsigned' to enable the use of the twos's complement for negative integers":"",this.root.isMutable.littleEndian?"\n * 'be' for big , 'le' for little endian byte order for case conversion":"",this.root.isMutable.padding?"\n * pass 'pad' to fill up, 'nopad' to not fill up the output with the particular padding":"",this.root.isMutable.upper?"\n * valid args for changing the encoded output case are 'upper' and 'lower'":"",`\n * valid args for the output type are ${this.#e(i)}`,e?`\n * the option(s) for version/charset are: ${this.#e(e)}`:"","\n * valid args for integrity check are: 'integrity' and 'nointegrity'",this.root.hasDecimalMode?"\n * 'decimal' for decimal-mode (directly converts Numbers including decimal values, without byte-conversion)":"","\n * 'number' for number-mode (converts every number into a Float64Array to keep the natural js number type)",Object.keys(this.converterArgs).length?`\n * converter specific args:\n   - ${(()=>Object.keys(this.converterArgs).map((t=>this.converterArgs[t].map((t=>`'${t}'`)).join(" and "))).join("\n   - "))()}`:"","\n\nTraceback:"].join(""))}validateArgs(i,s=!1){const o={decimalMode:this.root.decimalMode,integrity:this.root.integrity,littleEndian:this.root.littleEndian,numberMode:this.root.numberMode,options:this.root.options,outputType:this.root.outputType,padding:this.root.padding,signed:this.root.signed,upper:this.root.upper,version:this.root.version};for(const t in this.converterArgs)o[t]=this.root[t];if(!i.length)return s&&this.setIOHandlers(),o;const a=t=>!!i.includes(t)&&(i.splice(i.indexOf(t),1),!0),h=Object.keys(this.root.charsets),l={integrity:["nointegrity","integrity"],littleEndian:["be","le"],padding:["nopad","pad"],signed:["unsigned","signed"],upper:["lower","upper"],...this.converterArgs};if(s)if(a("bytes_only"))this.setIOHandlers(t,e);else{const i=a("bytes_in")?t:r,s=a("bytes_out")?e:n;this.setIOHandlers(i,s)}const c=this.outputHandler.typeList;if(a("number")&&(o.numberMode=!0,o.outputType="float_n"),a("decimal")){if(!this.root.hasDecimalMode)throw TypeError("Argument 'decimal' is only allowed for converters with a non-integer base.");o.decimalMode=!0,o.outputType="decimal",o.numberMode&&(o.numberMode=!1,console.warn("-> number-mode was disabled due to the decimal-mode"))}if(i.forEach((t=>{if("object"!=typeof t)if(t=String(t).toLowerCase(),h.includes(t))o.version=t;else if(c.includes(t))o.outputType=t;else{let e=!0;for(const i in l)if(l[i].includes(t)){if(e=!1,!this.root.isMutable[i])throw TypeError(`Argument '${t}' is not allowed for this type of converter.`);o[i]=Boolean(l[i].indexOf(t))}e&&this.#i(t,h,c,s)}else o.options={...o.options,...t}})),o.padding&&o.signed&&(o.padding=!1,console.warn("-> padding was set to false due to the signed conversion")),s)for(const t in o)this.root[t]=o[t];return o}signError(){throw new o}wrapOutput(t,e=0){if(!e)return t;const i=new RegExp(`.{1,${e}}`,"gu");return t.match(i).join("\n")}normalizeInput(t,e=!1){return e?String(t):String(t).replace(/\s/g,"")}}class l{constructor(t,e=null,i=null,s=0){this.radix=t,null!==e&&null!==i?(this.bsEnc=e,this.bsDec=i):[this.bsEnc,this.bsDec]=this.constructor.guessBS(t),this.decPadVal=s}static guessBS(t){let e=t<8?t:Math.ceil(256/t);for(;e>8&&!(e%8);)e/=8;let i=0;for(;8*i*Math.log(2)/Math.log(t)<e;)i++;return[i,Math.ceil(8*i*Math.log(2)/Math.log(t))]}encode(t,e,i=!1,s=null){let r=this.bsEnc;0===r&&(r=t.byteLength);let n="";const o=r?(r-t.length%r)%r:0,a=new Array(o).fill(0);let h;if(i?(t.reverse(),h=[...a,...t]):h=[...t,...a],10===this.radix){let t=0n;for(let e=0;e<r;e++)t=(t<<8n)+BigInt(h[e]);return[t.toString(),0]}for(let t=0,i=h.length;t<i;t+=r){let i=0n;for(let e=t;e<t+r;e++)i=(i<<8n)+BigInt(h[e]);const a=new Array;let l,c=i;for(;c>=this.radix;)[c,l]=this.divmod(c,this.radix),a.unshift(parseInt(l,10));for(a.unshift(parseInt(c,10));a.length<this.bsDec;)a.unshift(0);let u="";a.forEach((t=>u=u.concat(e[t]))),s&&(u=s(u,o)),n=n.concat(u)}return[n,o]}decode(t,e,i=[],s=!0,r=!1){if(!t)return new Uint8Array(0);let n=this.bsDec;const o=new Array;let h;if([...t].forEach((t=>{const r=e.indexOf(t);if(r>-1)o.push(r);else if(s&&-1===i.indexOf(t))throw new a(t)})),0===n)n=o.length;else{h=(n-o.length%n)%n;const t=new Array(h).fill(this.decPadVal);r?o.unshift(...t):o.push(...t)}let l=new Array;for(let t=0,e=o.length;t<e;t+=n){let e=0n;for(let i=0;i<n;i++)e+=BigInt(o[t+i])*this.pow(n-1-i);const i=new Array;let s,r=e;for(;r>=256;)[r,s]=this.divmod(r,256),i.unshift(parseInt(s,10));for(i.unshift(parseInt(r,10));i.length<this.bsEnc;)i.unshift(0);l=l.concat(i)}if(r){if(l.length>1){for(;!l[0];)l.shift();l.length||l.push(0),l.reverse()}}else if(this.bsDec){const t=this.padChars(h);l.splice(l.length-t)}return Uint8Array.from(l)}padBytes(t){return Math.floor(t*this.bsDec/this.bsEnc)}padChars(t){return Math.ceil(t*this.bsEnc/this.bsDec)}pow(t){return BigInt(this.radix)**BigInt(t)}divmod(t,e){return[t,e]=[BigInt(t),BigInt(e)],[t/e,t%e]}}class c{constructor(t=!0){this.charsets={},this.decimalMode=!1,this.frozenCharsets=!1,this.hasDecimalMode=!1,this.hasSignedMode=!1,this.integrity=!0,this.littleEndian=!1,this.numberMode=!1,this.outputType="buffer",this.padding=!1,this.padCharAmount=0,this.padChars={},this.signed=!1,this.upper=null,t&&(this.utils=new h(this)),this.version="default",this.options={lineWrap:0},this.isMutable={integrity:!0,littleEndian:!1,padding:!1,signed:!1,upper:!1}}encode(t,e,i,...s){const r=this.utils.validateArgs(s);let[n,o,a]=this.utils.inputHandler.toBytes(t,r),h=null;e&&(h=e(r));let[l,c]=this.converter.encode(n,this.charsets[r.version],r.littleEndian,h);return r.signed&&(l=this.utils.toSignedStr(l,o)),r.upper&&(l=l.toUpperCase()),i&&(l=i({inputBytes:n,output:l,settings:r,zeroPadding:c,type:a})),this.utils.wrapOutput(l,r.options.lineWrap)}decode(t,e,i,s,...r){const n=this.utils.validateArgs(r);t=this.utils.normalizeInput(t,s);let o=!1;this.hasSignedMode&&([t,o]=this.utils.extractSign(t),o&&!n.signed&&this.utils.signError()),this.isMutable.upper&&(t=t.toLowerCase()),e&&(t=e({input:t,settings:n}));let a=this.converter.decode(t,this.charsets[n.version],this.padChars[n.version],n.integrity,n.littleEndian);return i&&(a=i({input:t,output:a,settings:n})),this.utils.outputHandler.compile(a,n.outputType,n.littleEndian,o)}}class u extends c{constructor(...t){super(),this.charsets.all=[..." !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"],this.charsets.sequence=[..."Hello World!"],this.charsets.default=["1"],this.charsets.tmark=["|","#"],this.converter=new l(10,0,0),this.hasSignedMode=!0,this.littleEndian=!0,this.signed=!0,this.isMutable.charsets=!1,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e);let s,r;[s,r]=this.utils.inputHandler.toBytes(t,i);let n=this.converter.encode(s,null,i.littleEndian)[0],o=BigInt(n);if(o>Number.MAX_SAFE_INTEGER)throw new RangeError("Invalid string length.");o>16777216&&console.warn("The string length is really long. The JavaScript engine may have memory issues generating the output string."),o=Number(o);const a=this.charsets[i.version],h=a.length;let l="";if(1===h)l=a.at(0).repeat(o);else if("all"===i.version)for(let t=0;t<o;t++){l+=a[Math.floor(Math.random()*h)]}else if("tmark"===i.version){const t=o%5;o>4&&(l=a.at(1).repeat((o-t)/5)),l+=a.at(0).repeat(t)}else for(let t=0;t<o;t++)l+=a[t%h];return l=this.utils.toSignedStr(l,r),i.upper&&(l=l.toUpperCase()),this.utils.wrapOutput(l,i.options.lineWrap)}decode(t,...e){const i=this.utils.validateArgs(e);let s;if(t=this.utils.normalizeInput(t),[t,s]=this.utils.extractSign(t),"all"!==i.version){const e=[...new Set(this.charsets[i.version])].join(""),s=new RegExp(`[^${e}]`,"g");t=t.replace(s,"")}t=String(t.length);const r=this.converter.decode(t,[..."0123456789"],[],"",i.integrity,i.littleEndian);return this.utils.outputHandler.compile(r,i.outputType,i.littleEndian,s)}}class d extends c{constructor(...t){super(),this.converter=new l(16,1,2),this.charsets.default=[..."0123456789abcdef"],this.padChars.default=[],this.hasSignedMode=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(({input:t,settings:e})=>(t=t.replace(/^0x/,""),e.integrity||(t=t.toLowerCase().replace(/[^0-9a-f]/g,"")),t.length%2&&(t="0".concat(t)),t)),null,!1,...e)}}class f extends c{constructor(...t){super(),this.converter=new l(32,5,8),this.charsets.crockford=[..."0123456789abcdefghjkmnpqrstvwxyz"],this.padChars.crockford=["="],this.charsets.rfc3548=[..."abcdefghijklmnopqrstuvwxyz234567"],this.padChars.rfc3548=["="],this.charsets.rfc4648=[..."0123456789abcdefghijklmnopqrstuv"],this.padChars.rfc4648=["="],this.charsets.zbase32=[..."ybndrfg8ejkmcpqxot1uwisza345h769"],this.padChars.zbase32=["="],this.padCharAmount=1,this.hasSignedMode=!0,this.version="rfc4648",this.isMutable.littleEndian=!0,this.isMutable.padding=!0,this.isMutable.signed=!0,this.isMutable.upper=!0,this.utils.validateArgs(t,!0),this.padding=/rfc3548|rfc4648/.test(this.version),this.upper="crockford"===this.version}encode(t,...e){return super.encode(t,null,(({output:t,settings:e,zeroPadding:i})=>{if(!e.littleEndian&&i){const s=this.converter.padBytes(i),r=this.padChars[e.version].at(0);t=t.slice(0,-s),e.padding&&(t=t.concat(r.repeat(s)))}return t}),...e)}decode(t,...e){return super.decode(t,null,null,!1,...e)}}class p extends c{constructor(...t){super(),this.converter=new l(58,0,0),this.charsets.default=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],Object.defineProperty(this.padChars,"default",{get:()=>[this.charsets.default.at(0)]}),this.charsets.bitcoin=[..."123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],Object.defineProperty(this.padChars,"bitcoin",{get:()=>[this.charsets.bitcoin.at(0)]}),this.charsets.flickr=[..."123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],Object.defineProperty(this.padChars,"flickr",{get:()=>[this.charsets.flickr.at(0)]}),this.padding=!0,this.version="bitcoin",this.isMutable.padding=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(({inputBytes:t,output:e,settings:i,type:s})=>{if(i.padding&&"int"!==s){let s=0;const r=t.length,n=this.charsets[i.version].at(0);if(r){for(;!t[s];)if(s++,s===r){s=0;break}const i=s;i&&(e=n.repeat(i).concat(e))}}return e}),...e)}decode(t,...e){return super.decode(t,null,(({input:t,output:e,settings:i})=>{const s=this.charsets[i.version].at(0);if(i.padding&&t.length>1){let i=0;for(;t[i]===s;)i++;const r=i;r&&(e=Uint8Array.from([...new Array(r).fill(0),...e]))}return e}),!1,...e)}}class g extends c{constructor(...t){super(),this.converter=new l(64,3,4),this.charsets.default=[..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],this.padChars.default=["="],this.charsets.urlsafe=this.charsets.default.slice(0,-2).concat(["-","_"]),this.padChars.urlsafe=["="],this.padCharAmount=1,this.padding=!0,this.isMutable.padding=!0,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(({output:t,settings:e,zeroPadding:i})=>{if(i){const s=this.converter.padBytes(i),r=this.padChars[e.version].at(0);t=t.slice(0,-s),e.padding&&(t=t.concat(r.repeat(s)))}return t}),...e)}decode(t,...e){return super.decode(t,null,null,!1,...e)}}class b extends c{constructor(...t){super(),this.converter=new l(64,3,4),this.charsets.default=[..."`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"],Object.defineProperty(this.padChars,"default",{get:()=>[this.charsets.default.at(0)]}),this.charsets.original=[" ",...this.charsets.default.slice(1)],Object.defineProperty(this.padChars,"original",{get:()=>[this.charsets.original.at(0)]}),this.charsets.xx=[..."+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"],Object.defineProperty(this.padChars,"xx",{get:()=>[this.charsets.xx.at(0)]}),this.padding=!0,this.header=!1,this.utils.converterArgs.header=["noheader","header"],this.isMutable.header=!0,this.isMutable.integrity=!1,this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,null,(({output:t,settings:e,zeroPadding:i})=>{const s=this.charsets[e.version],r=[...t];if(e.header){t=`begin ${e.options.permissions||w()} ${e.options.file||y()}\n`}else t="";for(;;){const e=r.splice(0,60);if(!r.length){const r=this.converter.padChars(e.length)-i;t+=`${s.at(r)}${e.join("")}\n`;break}t+=`${s.at(45)}${e.join("")}\n`}return t+=`${s.at(0)}\n`,e.header&&(t+="\nend"),t}),...e)}decode(t,...e){let i=0;return super.decode(t,(({input:t,settings:e})=>{const s=this.charsets[e.version],r=t.trim().split(/\r?\n/),n=[];/^begin/i.test(r.at(0))&&r.shift();for(const t of r){const r=[...t],o=s.indexOf(r.shift());if(!(o>0))break;if(n.push(...r),45!==o){i=this.converter.padChars(r.length)-o;break}if(60!==r.length&&"original"===e.version)for(;n.length%60;)n.push(" ")}return n.join("")}),(({output:t})=>(i&&(t=new Uint8Array(t.slice(0,-i))),t)),!0,...e)}}const w=()=>{const t=()=>Math.floor(8*Math.random());return`${t()}${t()}${t()}`},y=()=>{const t=t=>t.at(Math.floor(Math.random()*t.length));return`${t(["unchronological","unconditionally","underemphasized","underprivileged","undistinguished","unsophisticated","untitled","untitled-1","untitled-3","uuencode"])}.${t(["applescript","bat","beam","bin","exe","js","mam","py","sh","vdo","wiz"])}`};class m extends c{constructor(...t){super(),this.converter=new l(85,4,5,84),this.charsets.adobe=[..."!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"],this.charsets.ascii85=this.charsets.adobe.slice(),this.charsets.rfc1924=[..."0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~"],this.charsets.z85=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&<>()[]{}@%$#"],this.version="ascii85",this.utils.validateArgs(t,!0)}encode(t,...e){return super.encode(t,(t=>{let e;return t.version.match(/adobe|ascii85/)&&(e=(t,e)=>e||"!!!!!"!==t?t:"z"),e}),(({output:t,settings:e,zeroPadding:i})=>{if(i){const e=this.converter.padBytes(i);t=t.slice(0,-e)}return"adobe"===e.version&&(t=`<~${t}~>`),t}),...e)}decode(t,...e){return super.decode(t,(({input:t,settings:e})=>(e.version.match(/adobe|ascii85/)&&(t=t.replace(/z/g,"!!!!!"),"adobe"===e.version&&(t=t.replace(/^<~|~>$/g,""))),t)),null,!1,...e)}}class v extends c{constructor(...t){super(),this.converter={radix:91,bsEnc:0,bsDec:0},this.charsets.default=[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'],this.version="default",this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e),s=this.utils.inputHandler.toBytes(t,i)[0];let r=0,n=0,o="";const a=this.charsets[i.version];if(s.forEach((t=>{if(n+=t<<r,r+=8,r>13){let t,e,i=13,s=n%8192;s<89&&(i=14,s=n%16384),n>>=i,r-=i,[t,e]=this.#s(s,91),o=`${o}${a[e]}${a[t]}`}})),r){let t,e;[t,e]=this.#s(n,91),o=o.concat(a[e]),(r>7||n>90)&&(o=o.concat(a[t]))}return this.utils.wrapOutput(o,i.options.lineWrap)}decode(t,...e){const i=this.utils.validateArgs(e),s=this.charsets[i.version];t=this.utils.normalizeInput(t);let r=[...t];i.integrity||(r=r.filter((t=>s.includes(t))));let n=r.length,o=!1;n%2&&(o=!0,n--);let h=0,l=0;const c=new Array;for(let t=0;t<n;t+=2){const e=s.indexOf(r[t]),i=s.indexOf(r[t+1]);if(e<0)throw new a(r[t]);if(i<0)throw new a(r[t+1]);const n=e+91*i;h=(n<<l)+h,l+=n%8192>88?13:14;do{c.push(h%256),h>>=8,l-=8}while(l>7)}if(o){const t=r.at(n),e=s.indexOf(t);c.push(((e<<l)+h)%256)}const u=Uint8Array.from(c);return this.utils.outputHandler.compile(u,i.outputType)}#s(t,e){return[Math.floor(t/e),t%e]}}class E extends c{constructor(...t){super(),this.converter=new l(10,0,0),this.hexlify=new l(16,1,2),this.charsets.default="<placeholder>",this.charsets.hex="<placeholder>",this.version="default",this.frozenCharsets=!0,this.littleEndian=!0,this.hasSignedMode=!0,this.isMutable.signed=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e),s=i.signed;i.signed=!0;const[r,n]=this.utils.inputHandler.toBytes(t,i);let o=this.converter.encode(r,null,i.littleEndian)[0],a=BigInt(o),h=new Array;if(n){if(!s)throw new TypeError("Negative values in unsigned mode are invalid.");a=-a}if(s)for(;;){const t=Number(127n&a);if(a>>=7n,0==a&&0==(64&t)||-1==a&&0!=(64&t)){h.push(t);break}h.push(128|t)}else for(;;){const t=Number(127n&a);if(a>>=7n,0==a){h.push(t);break}h.push(128|t)}const l=Uint8Array.from(h);return"hex"===i.version?this.hexlify.encode(l,[..."0123456789abcdef"],!1)[0]:l}decode(e,...i){const s=this.utils.validateArgs(i);if("hex"===s.version)e=this.hexlify.decode(this.utils.normalizeInput(e).toLowerCase(),[..."0123456789abcdef"],[],s.integrity,!1);else{if(void 0===e.byteLength)throw new TypeError("Input must be a bytes like object.");e=t.toBytes(e)[0]}if(1===e.length&&!e[0])return this.utils.outputHandler.compile(new Uint8Array(1),s.outputType,!0);e=Array.from(e);let r,n,o,a=0n,h=-7n;for(r of e)h+=7n,a+=BigInt(127&r)<<h;s.signed&&0!=(64&r)&&(a|=-(1n<<h+7n)),[n,o]=this.utils.extractSign(a.toString());const l=this.converter.decode(n,[..."0123456789"],[],s.integrity,!0);return this.utils.outputHandler.compile(l,s.outputType,!0,o)}}class A extends c{#r={};#n=null;constructor(...t){super(),this.charsets.emojis_v1=[..."🀄🃏🅰🅱🅾🅿🆎🆑🆒🆓🆔🆕🆖🆗🆘🆙🆚🇦🇧🇨🇩🇪🇫🇬🇭🇮🇯🇰🇱🇲🇳🇴🇵🇶🇷🇸🇹🇺🇻🇼🇽🇾🇿🈁🈂🈚🈯🈲🈳🈴🈵🈶🈷🈸🈹🈺🉐🉑🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🌡🌤🌥🌦🌧🌨🌩🌪🌫🌬🌭🌮🌯🌰🌱🌲🌳🌴🌵🌶🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🍽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🎖🎗🎙🎚🎛🎞🎟🎠🎡🎢🎣🎤🎥🎦🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏳🏴🏵🏷🏸🏹🏺🏻🏼🏽🏾🏿🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🐿👀👁👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸💹💺💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📿🔀🔁🔂🔃🔄🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🔙🔚🔛🔜🔝🔞🔟🔠🔡🔢🔣🔤🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🔴🔵🔶🔷🔸🔹🔺🔻🔼🔽🕉🕊🕋🕌🕍🕎🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕛🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕧🕯🕰🕳🕴🕵🕶🕷🕸🕹🕺🖇🖊🖋🖌🖍🖐🖕🖖🖤🖥🖨🖱🖲🖼🗂🗃🗄🗑🗒🗓🗜🗝🗞🗡🗣🗨🗯🗳🗺🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🛋🛌🛍🛎🛏🛐🛑🛒🛠🛡🛢🛣🛤🛥🛩🛫🛬🛰🛳🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🦰🦱🦲🦳🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v1=["⚜","🏍","📑","🙋","☕"],this.charsets.emojis_v2=[..."🀄🃏⏰⏳☔♈♉♊♋♌♍♎♏♐♑♒♓♿⚓⚡⚽⚾⛄⛅⛎⛔⛪⛲⛳⛵⛺⛽✊✋✨⭐🛕🛖🛗🛝🛞🛟🛺🈁🛻🤌🤏🤿🥱🥲🥸🥹🥻🦣🦤🦥🦦🦧🌀🌁🌂🌃🌄🌅🌆🌇🌈🌉🌊🌋🌌🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝🌞🌟🌠🦨🦩🦪🦫🦬🦭🦮🦯🦺🦻🌭🌮🌯🌰🌱🌲🌳🌴🌵🦼🌷🌸🌹🌺🌻🌼🌽🌾🌿🍀🍁🍂🍃🍄🍅🍆🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍔🍕🍖🍗🍘🍙🍚🍛🍜🍝🍞🍟🍠🍡🍢🍣🍤🍥🍦🍧🍨🍩🍪🍫🍬🍭🍮🍯🍰🍱🍲🍳🍴🍵🍶🍷🍸🍹🍺🍻🍼🦽🍾🍿🎀🎁🎂🎃🎄🎅🎆🎇🎈🎉🎊🎋🎌🎍🎎🎏🎐🎑🎒🎓🦾🦿🧃🧄🧅🧆🧇🎠🎡🎢🎣🎤🎥🧈🎧🎨🎩🎪🎫🎬🎭🎮🎯🎰🎱🎲🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🧉🧊🧋🏏🏐🏑🏒🏓🧌🧍🧎🧏🧖🧗🧘🧙🧚🧛🧜🧝🏠🏡🏢🏣🏤🏥🏦🧞🏨🏩🏪🏫🏬🏭🏮🏯🏰🧟🏴🧠🧢🏸🏹🏺🧣🧤🧥🧦🧧🐀🐁🐂🐃🐄🐅🐆🐇🐈🐉🐊🐋🐌🐍🐎🐏🐐🐑🐒🐓🐔🐕🐖🐗🐘🐙🐚🐛🐜🐝🐞🐟🐠🐡🐢🐣🐤🐥🐦🐧🐨🐩🐪🐫🐬🐭🐮🐯🐰🐱🐲🐳🐴🐵🐶🐷🐸🐹🐺🐻🐼🐽🐾🧨👀🧩👂👃👄👅👆👇👈👉👊👋👌👍👎👏👐👑👒👓👔👕👖👗👘👙👚👛👜👝👞👟👠👡👢👣👤👥👦👧👨👩👪👫👬👭👮👯👰👱👲👳👴👵👶👷👸👹👺👻👼👽👾👿💀💁💂💃💄💅💆💇💈💉💊💋💌💍💎💏💐💑💒💓💔💕💖💗💘💙💚💛💜💝💞💟💠💡💢💣💤💥💦💧💨💩💪💫💬💭💮💯💰💱💲💳💴💵💶💷💸🧪💺💻💼💽💾💿📀🧫📂📃📄🧬📆📇📈📉📊📋📌📍📎📏📐📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳🧭📵📶📷📸📹📺📻📼🧮📿🧯🧰🧱🧲🧳🔅🔆🔇🔈🔉🔊🔋🔌🔍🔎🔏🔐🔑🔒🔓🔔🔕🔖🔗🔘🧴🧵🧶🧷🧸🧹🧺🧻🧼🧽🧾🧿🔥🔦🔧🔨🔩🔪🔫🔬🔭🔮🔯🔰🔱🔲🔳🩰🩱🩲🩳🩴🩸🩹🩺🩻🩼🪀🪁🕋🕌🕍🕎🪂🪃🪄🪅🪆🪐🪑🪒🪓🪔🪕🪖🪗🪘🪙🪚🪛🪜🪝🪞🪟🪠🪡🪢🪣🪤🪥🪦🪧🪨🪩🪪🪫🕺🪬🪰🪱🪲🪳🪴🖕🖖🖤🪵🪶🪷🪸🪹🪺🫀🫁🫂🫃🫄🫅🫐🫑🫒🫓🫔🫕🫖🫗🗻🗼🗽🗾🗿😀😁😂😃😄😅😆😇😈😉😊😋😌😍😎😏😐😑😒😓😔😕😖😗😘😙😚😛😜😝😞😟😠😡😢😣😤😥😦😧😨😩😪😫😬😭😮😯😰😱😲😳😴😵😶😷😸😹😺😻😼😽😾😿🙀🙁🙂🙃🙄🙅🙆🙇🙈🙉🙊🙌🙍🙎🙏🚀🚁🚂🚃🚄🚅🚆🚇🚈🚉🚊🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚙🚚🚛🚜🚝🚞🚟🚠🚡🚢🚣🚤🚥🚦🚧🚨🚩🚪🚫🚬🚭🚮🚯🚰🚱🚲🚳🚴🚵🚶🚷🚸🚹🚺🚻🚼🚽🚾🚿🛀🛁🛂🛃🛄🛅🫘🛌🫙🫠🫡🛐🛑🛒🫢🫣🫤🫥🫦🫧🫰🛫🛬🫱🫲🛴🛵🛶🛷🛸🛹🤐🤑🤒🤓🤔🤕🤖🤗🤘🤙🤚🤛🤜🤝🤞🤟🤠🤡🤢🤣🤤🤥🤦🤧🤨🤩🤪🤫🤬🤭🤮🤯🤰🤱🤲🤳🤴🤵🤶🤷🤸🤹🤺🤼🤽🤾🥀🥁🥂🥃🥄🥅🥇🥈🥉🥊🥋🥌🥍🥎🥏🥐🥑🥒🥓🥔🥕🥖🥗🥘🥙🥚🥛🥜🥝🥞🥟🥠🥡🥢🥣🥤🥥🥦🥧🥨🥩🥪🥫🥬🥭🥮🥯🥰🥳🥴🥵🥶🥺🥼🥽🥾🥿🦀🦁🦂🦃🦄🦅🦆🦇🦈🦉🦊🦋🦌🦍🦎🦏🦐🦑🦒🦓🦔🦕🦖🦗🦘🦙🦚🦛🦜🦝🦞🦟🦠🦡🦢🫳🫴🫵🫶🦴🦵🦶🦷🦸🦹🧀🧁🧂🧐🧑🧒🧓🧔🧕"],this.padChars.emojis_v2=["🥷","🛼","📑","🙋","☕"],this.#o(),this.converter=new l(1024,5,4),this.padding=!0,this.padCharAmount=5,this.version="emojis_v2",this.isMutable.padding=!0,this.isMutable.trim=!0,this.trim=null,this.utils.converterArgs.trim=["notrim","trim"],this.utils.validateArgs(t,!0),null===this.trim&&(this.trim="emojis_v2"===this.version)}#o(){const t={},e=(t,e)=>{e.forEach((e=>{e in this.#r?this.#r[e].version+=t:this.#r[e]={version:t}}))},i=(e,i,s)=>{i.forEach((i=>{i in t?this.#r[i].version=3:(this.#r[i]={version:e,padding:s},t[i]=s)}))};e(1,this.charsets.emojis_v1),e(2,this.charsets.emojis_v2),i(1,this.padChars.emojis_v1.slice(0,-1),"last"),i(2,this.padChars.emojis_v2.slice(0,-1),"last"),i(1,this.padChars.emojis_v1.slice(-1),"fill"),i(2,this.padChars.emojis_v2.slice(-1),"fill");const s=[];for(const e in t)"last"===t[e]?s.push(e):s.push(`${e}+`);this.#n=new RegExp(s.join("|"),"g")}encode(t,...e){return super.encode(t,null,(({output:t,settings:e,zeroPadding:i})=>{const s=this.charsets[e.version];let r=[...t];if(i>1){const t=this.converter.padBytes(i);if(e.padding){const i=e.trim?1:t,s=new Array(i).fill(this.padChars[e.version].at(-1));r.splice(r.length-t,t,...s)}else r.splice(r.length-t,t)}else if(1===i){const t=s.indexOf(r.pop())>>8;r.push(this.padChars[e.version].at(t))}return r.join("")}),...e)}decode(t,...e){const i=this.utils.validateArgs(e);t=this.utils.normalizeInput(t);let s=i.version,r=null;"emojis_v1"!==i.version&&"emojis_v2"!==i.version||(r=3);const n=t=>{null!==r&&(r=this.#a(t,r,i.integrity),s=3===r?i.version:`emojis_v${r}`);const e=this.charsets[s],n=[...t],o=n.at(-1);let a=!1;for(let i=0;i<this.padChars[s].length-1;i++)if(o===this.padChars[s].at(i)){n.splice(-1,1,e.at(i<<8)),t=n.join(""),a=!0;break}let h=this.converter.decode(t,this.charsets[s],[],!1);return a&&(h=new Uint8Array(h.buffer.slice(0,-1))),h},o=[...t.matchAll(this.#n)];let a;if(o.length<2)a=n(t);else{const e=[];let i=0;o.forEach((s=>{const r=s.index+s.at(0).length;e.push(...n(t.slice(i,r))),i=r})),i!==t.length&&e.push(...n(t.slice(i,t.length))),a=Uint8Array.from(e)}return this.utils.outputHandler.compile(a,i.outputType)}#a(t,e,i){const s=[...t];let r;if(s.forEach(((t,s)=>{if(!(t in this.#r))throw new a(t);{const n=this.#r[t].version;if(3!==n)if(3===e)e=n;else if(e!==n)throw new TypeError(`Emojis from different ecoji versions seen : ${t} from emojis_v${n}`);if(i){const e=this.#r[t].padding;if(e){const i=s%4;if(r=!0,"fill"===e){if(0===i)throw new TypeError(`Padding unexpectedly seen in first position ${t}`)}else if(3!==i)throw new TypeError(`Last padding seen in unexpected position ${t}`)}else if(r)throw new TypeError("Unexpectedly saw non-padding after padding")}}})),i&&s.length%4&&(1===e||"fill"!==this.#r[s.at(-1)].padding))throw new TypeError("Unexpected end of data, input data size not multiple of 4");return e}}class x extends c{constructor(...t){super(),this.converter={radix:2048,bsEnc:11,bsEncPad:3,bsDec:8},this.charsets.default=[..."89ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÆÐØÞßæðøþĐđĦħıĸŁłŊŋŒœŦŧƀƁƂƃƄƅƆƇƈƉƊƋƌƍƎƏƐƑƒƓƔƕƖƗƘƙƚƛƜƝƞƟƢƣƤƥƦƧƨƩƪƫƬƭƮƱƲƳƴƵƶƷƸƹƺƻƼƽƾƿǀǁǂǃǝǤǥǶǷȜȝȠȡȢȣȤȥȴȵȶȷȸȹȺȻȼȽȾȿɀɁɂɃɄɅɆɇɈɉɊɋɌɍɎɏɐɑɒɓɔɕɖɗɘəɚɛɜɝɞɟɠɡɢɣɤɥɦɧɨɩɪɫɬɭɮɯɰɱɲɳɴɵɶɷɸɹɺɻɼɽɾɿʀʁʂʃʄʅʆʇʈʉʊʋʌʍʎʏʐʑʒʓʔʕʖʗʘʙʚʛʜʝʞʟʠʡʢʣʤʥʦʧʨʩʪʫʬʭʮʯͰͱͲͳͶͷͻͼͽͿΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρςστυφχψωϏϗϘϙϚϛϜϝϞϟϠϡϢϣϤϥϦϧϨϩϪϫϬϭϮϯϳϷϸϺϻϼϽϾϿЂЄЅІЈЉЊЋЏАБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзиклмнопрстуфхцчшщъыьэюяђєѕіјљњћџѠѡѢѣѤѥѦѧѨѩѪѫѬѭѮѯѰѱѲѳѴѵѸѹѺѻѼѽѾѿҀҁҊҋҌҍҎҏҐґҒғҔҕҖҗҘҙҚқҜҝҞҟҠҡҢңҤҥҦҧҨҩҪҫҬҭҮүҰұҲҳҴҵҶҷҸҹҺһҼҽҾҿӀӃӄӅӆӇӈӉӊӋӌӍӎӏӔӕӘәӠӡӨөӶӷӺӻӼӽӾӿԀԁԂԃԄԅԆԇԈԉԊԋԌԍԎԏԐԑԒԓԔԕԖԗԘԙԚԛԜԝԞԟԠԡԢԣԤԥԦԧԨԩԪԫԬԭԮԯԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖաբգդեզէըթժիլխծկհձղճմյնշոչպջռսվտրցւփքօֆאבגדהוזחטיךכלםמןנסעףפץצקרשתװױײؠءابةتثجحخدذرزسشصضطظعغػؼؽؾؿفقكلمنهوىي٠١٢٣٤٥٦٧٨٩ٮٯٱٲٳٴٹٺٻټٽپٿڀځڂڃڄڅچڇڈډڊڋڌڍڎڏڐڑڒړڔڕږڗژڙښڛڜڝڞڟڠڡڢڣڤڥڦڧڨکڪګڬڭڮگڰڱڲڳڴڵڶڷڸڹںڻڼڽھڿہۃۄۅۆۇۈۉۊۋیۍێۏېۑےەۮۯ۰۱۲۳۴۵۶۷۸۹ۺۻۼۿܐܒܓܔܕܖܗܘܙܚܛܜܝܞܟܠܡܢܣܤܥܦܧܨܩܪܫܬܭܮܯݍݎݏݐݑݒݓݔݕݖݗݘݙݚݛݜݝݞݟݠݡݢݣݤݥݦݧݨݩݪݫݬݭݮݯݰݱݲݳݴݵݶݷݸݹݺݻݼݽݾݿހށނރބޅކއވމފދތލގޏސޑޒޓޔޕޖޗޘޙޚޛޜޝޞޟޠޡޢޣޤޥޱ߀߁߂߃߄߅߆߇߈߉ߊߋߌߍߎߏߐߑߒߓߔߕߖߗߘߙߚߛߜߝߞߟߠߡߢߣߤߥߦߧߨߩߪࠀࠁࠂࠃࠄࠅࠆࠇࠈࠉࠊࠋࠌࠍࠎࠏࠐࠑࠒࠓࠔࠕࡀࡁࡂࡃࡄࡅࡆࡇࡈࡉࡊࡋࡌࡍࡎࡏࡐࡑࡒࡓࡔࡕࡖࡗࡘࡠࡡࡢࡣࡤࡥࡦࡧࡨࡩࡪࢠࢡࢢࢣࢤࢥࢦࢧࢨࢩࢪࢫࢬࢭࢮࢯࢰࢱࢲࢳࢴࢶࢷࢸࢹࢺࢻࢼࢽऄअआइईउऊऋऌऍऎएऐऑऒओऔकखगघङचछजझञटठडढणतथदधनपफबभमयरलळवशषसहऽॐॠॡ०१२३४५६७८९ॲॳॴॵॶॷॸॹॺॻॼॽॾॿঀঅআইঈউঊঋঌএঐওঔকখগঘঙচছজঝঞটঠডঢণতথদধনপফবভমযরলশষসহঽৎৠৡ০১২৩৪৫৬৭৮৯ৰৱ৴৵৶৷৸৹ৼਅਆਇਈਉਊਏਐਓਔਕਖਗਘਙਚਛਜਝਞਟਠਡਢਣਤਥਦਧਨਪਫਬਭਮਯਰਲਵਸਹੜ੦੧੨੩੪੫੬੭੮੯ੲੳੴઅઆઇઈઉઊઋઌઍએઐઑઓઔકખગઘઙચછજઝઞટઠડઢણતથદધનપફબભમયરલળવશષસહઽૐૠૡ૦૧૨૩૪૫૬૭૮૯ૹଅଆଇଈଉଊଋଌଏଐଓଔକଖଗଘଙଚଛଜଝଞଟଠଡଢଣତଥଦଧନପଫବଭମଯରଲଳଵଶଷସହଽୟୠୡ୦୧୨୩୪୫୬୭୮୯ୱ୲୳୴୵୶୷ஃஅஆஇஈஉஊஎஏஐஒஓகஙசஜஞடணதநனபமயரறலளழவஶஷஸஹௐ௦௧௨௩௪௫௬௭௮௯௰௱௲అఆఇఈఉఊఋఌఎఏఐఒఓఔకఖగఘఙచఛజఝఞటఠడఢణతథదధనపఫబభమయరఱలళఴవశషసహఽౘౙౚౠౡ౦౧౨౩౪౫౬౭౮౯౸౹౺౻౼౽౾ಀಅಆಇಈಉಊಋಌಎಏಐಒಓಔಕಖಗಘಙಚಛಜಝಞಟಠಡಢಣತಥದಧನಪಫಬಭಮಯರಱಲಳವಶಷಸಹಽೞೠೡ೦೧೨೩೪೫೬೭೮೯ೱೲഅആഇഈഉഊഋഌഎഏഐഒഓഔകഖഗഘങചഛജഝഞടഠഡഢണതഥദധനഩപഫബഭമയരറലളഴവശഷസഹഺഽൎൔൕൖ൘൙൚൛൜൝൞ൟൠൡ൦൧൨൩൪൫൬൭൮൯൰൱൲൳൴൵൶൷൸ൺൻർൽൾൿඅආඇඈඉඊඋඌඍඎඏඐඑඒඓඔඕඖකඛගඝඞඟචඡජඣඤඥඦටඨඩඪණඬතථදධනඳපඵබභමඹයරලවශෂසහළෆ෦෧෨෩෪෫෬෭෮෯กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะาเแโใไๅ๐๑๒๓๔๕๖๗๘๙ກຂຄງຈຊຍດຕຖທນບປຜຝພຟມຢຣລວສຫອຮຯະາຽເແໂໃໄ໐໑໒໓໔໕໖໗໘໙ໞໟༀ༠༡༢༣༤༥༦༧༨༩༪༫༬༭༮༯༰༱༲༳ཀཁགངཅཆཇཉཊཋཌཎཏཐདནཔཕབམཙཚཛཝཞཟའཡརལཤཥསཧཨཪཫཬྈྉྊྋྌကခဂဃငစဆဇဈဉညဋဌဍဎဏတထဒဓနပဖဗဘမယရလဝသဟဠအဢဣဤဥဧဨဩဪဿ၀၁၂၃၄၅၆၇၈၉ၐၑၒၓၔၕ"],this.padChars.default=[..."01234567"],this.padCharAmount=8,this.hasSignedMode=!0,this.littleEndian=!1,this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e);let s=this.utils.inputHandler.toBytes(t,i).at(0);const r=this.charsets[i.version],n=this.padChars[i.version];let o="",a=0,h=0;if(s.forEach((t=>{for(let e=this.converter.bsDec-1;e>=0;e--)a=(a<<1)+(t>>e&1),h++,h===this.converter.bsEnc&&(o+=r.at(a),a=0,h=0)})),0!==h){let t,e;for(h<=this.converter.bsEncPad?(t=this.converter.bsEncPad,e=!0):(t=this.converter.bsEnc,e=!1);h!==t;)if(a=1+(a<<1),h++,h>this.converter.bsEnc)throw new Error("Cannot process input. This is a bug!");o+=e?n.at(a):r.at(a)}return this.utils.wrapOutput(o,i.options.lineWrap)}decode(t,...e){const i=this.utils.validateArgs(e);t=this.utils.normalizeInput(t);const s=[...t],r=this.charsets[i.version],n=this.padChars[i.version],o=new Array;let h=0,l=0;return s.forEach(((t,e)=>{let c,u=r.indexOf(t);if(u>-1)c=this.converter.bsEnc;else if(u=n.indexOf(t),u>-1){if(e+1!==s.length)throw new a(null,`Secondary character found before end of input, index: ${e}`);c=this.converter.bsEncPad}else if(i.integrity)throw new a(t);for(let t=c-1;t>=0;t--)h=(h<<1)+(u>>t&1),l++,l===this.converter.bsDec&&(o.push(h),h=0,l=0)})),this.utils.outputHandler.compile(Uint8Array.from(o),i.outputType)}}class T extends c{constructor(t,...e){if(super(),!t||!Number.isInteger(t)||t<2||t>62)throw new RangeError("Radix argument must be provided and has to be an integer between 2 and 62.");this.converter=new l(t,0,0),this.charsets.default=[..."0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"].slice(0,t),this.frozenCharsets=!0,this.hasSignedMode=!0,this.littleEndian=!(2===t||16===t),this.signed=!0,this.version="default",this.isMutable.littleEndian=!0,this.isMutable.upper=t<=36,this.utils.validateArgs(e,!0)}encode(t,...e){return super.encode(t,null,null,...e)}decode(t,...e){return super.decode(t,(({input:t})=>{if(2===this.converter.radix){const e=(8-t.length%8)%8;t=`${"0".repeat(e)}${t}`}else if(16===this.converter.radix){const e=t.length%2;t=`${"0".repeat(e)}${t}`}return t}),null,!1,...e)}}let M=1e6,j="[big.js] ",C=j+"Invalid ",$=C+"decimal places",I=C+"rounding mode",k={},B=/^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;function _(t,e,i,s){let r=t.c;if(void 0===i&&(i=t.constructor.RM),0!==i&&1!==i&&2!==i&&3!==i)throw Error(I);if(e<1)s=3===i&&(s||!!r[0])||0===e&&(1===i&&r[0]>=5||2===i&&(r[0]>5||5===r[0]&&(s||void 0!==r[1]))),r.length=1,s?(t.e=t.e-e+1,r[0]=1):r[0]=t.e=0;else if(e<r.length){if(s=1===i&&r[e]>=5||2===i&&(r[e]>5||5===r[e]&&(s||void 0!==r[e+1]||1&r[e-1]))||3===i&&(s||!!r[0]),r.length=e,s)for(;++r[--e]>9;)if(r[e]=0,0===e){++t.e,r.unshift(1);break}for(e=r.length;!r[--e];)r.pop()}return t}function S(t,e,i){let s=t.e,r=t.c.join(""),n=r.length;if(e)r=r.charAt(0)+(n>1?"."+r.slice(1):"")+(s<0?"e":"e+")+s;else if(s<0){for(;++s;)r="0"+r;r="0."+r}else if(s>0)if(++s>n)for(s-=n;s--;)r+="0";else s<n&&(r=r.slice(0,s)+"."+r.slice(s));else n>1&&(r=r.charAt(0)+"."+r.slice(1));return t.s<0&&i?"-"+r:r}k.abs=function(){let t=new this.constructor(this);return t.s=1,t},k.cmp=function(t){let e,i=this,s=i.c,r=(t=new i.constructor(t)).c,n=i.s,o=t.s,a=i.e,h=t.e;if(!s[0]||!r[0])return s[0]?n:r[0]?-o:0;if(n!=o)return n;if(e=n<0,a!=h)return a>h^e?1:-1;for(o=(a=s.length)<(h=r.length)?a:h,n=-1;++n<o;)if(s[n]!=r[n])return s[n]>r[n]^e?1:-1;return a==h?0:a>h^e?1:-1},k.eq=function(t){return 0===this.cmp(t)},k.gt=function(t){return this.cmp(t)>0},k.gte=function(t){return this.cmp(t)>-1},k.lt=function(t){return this.cmp(t)<0},k.lte=function(t){return this.cmp(t)<1},k.minus=k.sub=function(t){let e,i,s,r,n=this,o=n.constructor,a=n.s,h=(t=new o(t)).s;if(a!=h)return t.s=-h,n.plus(t);let l=n.c.slice(),c=n.e,u=t.c,d=t.e;if(!l[0]||!u[0])return u[0]?t.s=-h:l[0]?t=new o(n):t.s=1,t;if(a=c-d){for((r=a<0)?(a=-a,s=l):(d=c,s=u),s.reverse(),h=a;h--;)s.push(0);s.reverse()}else for(i=((r=l.length<u.length)?l:u).length,a=h=0;h<i;h++)if(l[h]!=u[h]){r=l[h]<u[h];break}if(r&&(s=l,l=u,u=s,t.s=-t.s),(h=(i=u.length)-(e=l.length))>0)for(;h--;)l[e++]=0;for(h=e;i>a;){if(l[--i]<u[i]){for(e=i;e&&!l[--e];)l[e]=9;--l[e],l[i]+=10}l[i]-=u[i]}for(;0===l[--h];)l.pop();for(;0===l[0];)l.shift(),--d;return l[0]||(t.s=1,l=[d=0]),t.c=l,t.e=d,t},k.plus=k.add=function(t){let e,i,s,r=this,n=r.constructor;if(t=new n(t),r.s!=t.s)return t.s=-t.s,r.minus(t);let o=r.e,a=r.c,h=t.e,l=t.c;if(!a[0]||!l[0])return l[0]||(a[0]?t=new n(r):t.s=r.s),t;if(a=a.slice(),e=o-h){for(e>0?(h=o,s=l):(e=-e,s=a),s.reverse();e--;)s.push(0);s.reverse()}for(a.length-l.length<0&&(s=l,l=a,a=s),e=l.length,i=0;e;a[e]%=10)i=(a[--e]=a[e]+l[e]+i)/10|0;for(i&&(a.unshift(i),++h),e=a.length;0===a[--e];)a.pop();return t.c=a,t.e=h,t},k.round=function(t,e){if(void 0===t)t=0;else if(t!==~~t||t<-M||t>M)throw Error($);return _(new this.constructor(this),t+this.e+1,e)},k.toFixed=function(t,e){let i=this,s=i.c[0];if(void 0!==t){if(t!==~~t||t<0||t>M)throw Error($);for(i=_(new i.constructor(i),t+i.e+1,e),t=t+i.e+1;i.c.length<t;)i.c.push(0)}return S(i,!1,!!s)},k[Symbol.for("nodejs.util.inspect.custom")]=k.toJSON=k.toString=function(){let t=this,e=t.constructor;return S(t,t.e<=e.NE||t.e>=e.PE,!!t.c[0])},k.toNumber=function(){let t=Number(S(this,!0,!0));if(!0===this.constructor.strict&&!this.eq(t.toString()))throw Error(j+"Imprecise conversion");return t};const N=function t(){function e(i){let s=this;if(!(s instanceof e))return void 0===i?t():new e(i);if(i instanceof e)s.s=i.s,s.e=i.e,s.c=i.c.slice();else{if("string"!=typeof i){if(!0===e.strict&&"bigint"!=typeof i)throw TypeError(C+"value");i=0===i&&1/i<0?"-0":String(i)}!function(t,e){let i,s,r;if(!B.test(e))throw Error(`${C}number`);for(t.s="-"==e.charAt(0)?(e=e.slice(1),-1):1,(i=e.indexOf("."))>-1&&(e=e.replace(".","")),(s=e.search(/e/i))>0?(i<0&&(i=s),i+=+e.slice(s+1),e=e.substring(0,s)):i<0&&(i=e.length),r=e.length,s=0;s<r&&"0"==e.charAt(s);)++s;if(s==r)t.c=[t.e=0];else{for(;r>0&&"0"==e.charAt(--r););for(t.e=i-s-1,t.c=[],i=0;s<=r;)t.c[i++]=+e.charAt(s++)}}(s,i)}s.constructor=e}return e.prototype=k,e.DP=20,e.RM=1,e.NE=-7,e.PE=21,e.strict=false,e.roundDown=0,e.roundHalfUp=1,e.roundHalfEven=2,e.roundUp=3,e}();class U extends c{#h=N("1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752");constructor(...t){super(),this.converter={radix:2,bsEnc:0,bsDec:0},this.b10=new l(10,0,0),this.charsets.default=["0","1"],this.version="default",this.signed=!0,this.hasDecimalMode=!0,this.utils.validateArgs(t,!0)}encode(t,...e){const i=this.utils.validateArgs(e),s=this.charsets[i.version];let r,n,o,a="";if(i.decimalMode){if(!Number.isFinite(t))throw new TypeError("When running the converter in decimal-mode, only input of type 'Number' is allowed.");t<0?(n=!0,o=N(-t)):(n=!1,o=N(t))}else[r,n]=this.utils.inputHandler.toBytes(t,i),o=N(this.b10.encode(r,null,i.littleEndian)[0]);if(o.eq(0)||o.eq(1))return a=s[o.toNumber()],n&&(a=`-${a}`),a;const h=[],l=[];let c=N(1),u=this.#h,d=0;for(;u.lt(o);)[c,u]=this.#l(c,u),d++;const f=(t,e,i)=>{if(!this.#c(o)){for(;t.gt(o);){if([t,e]=this.#u(t,e),t.lte(0))return void console.warn("Could not find an exact base-phi representation. Value is approximated.");i--}i>-1?h.unshift(i):l.push(i),o=o.minus(t),f(t,e,i)}};return f(c,u,d),d=0,h.forEach((t=>{for(;d<t;)a=`${s[0]}${a}`,d++;a=`${s[1]}${a}`,d++})),a?a+=".":a="0.",d=-1,l.forEach((t=>{for(;d>t;)a+=s[0],d--;a+=s[1],d--})),n&&(a=`-${a}`),a}decode(t,...e){const i=this.utils.validateArgs(e),s=this.charsets[i.version];let r;if([t,r]=this.utils.extractSign(this.utils.normalizeInput(t)),!i.integrity){const e=[...s,"."];t=[...t].filter((t=>e.includes(t))).join("")}const n=t.split(".");if(i.integrity&&n.length>2)throw new a(null,"There are multiple decimal points in the input.");const[o,h]=n;let l=N(0),c=this.#h.minus(1),u=N(1);if([...o].reverse().forEach((t=>{const e=s.indexOf(t);if(1===e)l=l.plus(u);else if(0!==e)throw new a(t);[c,u]=this.#l(c,u)})),h){let t=N(1);u=this.#h.minus(t),[...h].forEach((e=>{const i=s.indexOf(e);if(1===i)l=l.plus(u);else if(0!==i)throw new a(e);[u,t]=this.#u(u,t)}))}if(i.decimalMode)return l.toNumber();l=l.round().toFixed();const d=this.b10.decode(l,[..."0123456789"],[],i.integrity,i.littleEndian);return this.utils.outputHandler.compile(d,i.outputType,i.littleEndian,r)}#c(t){return!t.round(50).abs().toNumber()}#l(t,e){return[e,t.plus(e)]}#u(t,e){return[e.minus(t),t]}}const D=(()=>{const t=new Uint16Array([1]),e=new Uint8Array(t.buffer);return Boolean(e.at(0))})();class P{constructor(...t){this.littleEndian=D,this.numberMode=!1,this.outputType="buffer",this.utils={validateArgs:(t,e=!1)=>{const i={littleEndian:this.littleEndian,numberMode:this.numberMode,outputType:this.outputType,signed:!1};if(!t.length)return i;t.includes("number")&&(t.splice(t.indexOf("number"),1),i.numberMode=!0,i.outputType="float_n");const r=s.typeList.map((t=>`'${t}'`)).join(", ");if(t.forEach((t=>{if("le"===(t=String(t).toLowerCase()))i.littleEndian=!0;else if("be"===t)i.littleEndian=!1;else{if(!s.typeList.includes(t))throw new TypeError(`Invalid argument: '${t}.\nValid arguments are:\n'le', 'be', ${r}`);i.outputType=t}})),e)for(const t in i)this[t]=i[t];return i}},this.utils.validateArgs(t,!0)}encode(t,...e){const s=this.utils.validateArgs(e);return i.toBytes(t,s)[0]}decode(t,...e){const i=this.utils.validateArgs(e);return s.compile(t,i.outputType,i.littleEndian)}}
/**
 * [BaseEx]{@link https://github.com/UmamiAppearance/BaseExJS}
 *
 * @version 0.7.7
 * @author UmamiAppearance [mail@umamiappearance.eu]
 * @license MIT
 */class O{constructor(t="buffer"){if(!n.typeList.includes(t)){let e=`Invalid argument '${t}' for output type. Allowed types are:\n`;throw e=e.concat(n.typeList.join(", ")),new TypeError(e)}this.base1=new u("default",t),this.base16=new d("default",t),this.base32_crockford=new f("rfc4648",t),this.base32_rfc3548=new f("rfc3548",t),this.base32_rfc4648=new f("rfc4648",t),this.base32_zbase32=new f("zbase32",t),this.base58=new p("default",t),this.base58_bitcoin=new p("bitcoin",t),this.base58_flickr=new p("flickr",t),this.base64=new g("default",t),this.base64_urlsafe=new g("urlsafe",t),this.uuencode=new b("default",t),this.uuencode_original=new b("original",t),this.xxencode=new b("xx",t),this.base85_adobe=new m("adobe",t),this.base85_ascii=new m("ascii85",t),this.base85_z85=new m("z85",t),this.base91=new v("default",t),this.leb128=new E("default",t),this.ecoji_v1=new A("emojis_v1",t),this.ecoji_v2=new A("emojis_v2",t),this.base2048=new x("default",t),this.basePhi=new U("default",t),this.byteConverter=new P(t),this.simpleBase={};for(let e=2;e<=62;e++)this.simpleBase[`base${e}`]=new T(e,t)}}export{u as Base1,d as Base16,x as Base2048,f as Base32,p as Base58,g as Base64,m as Base85,v as Base91,O as BaseEx,U as BasePhi,P as ByteConverter,A as Ecoji,E as LEB128,T as SimpleBase,b as UUencode};
